# ch1. 리엑트 안티패턴 소개

## 관련 주제

- UI 구축의 어려움에 대한 이해
- 상태 관리의 이해
- 예외 흐름 살펴보기
- 리엑트의 일반적인 안티패턴 살펴보기

## 1.1 UI 구축의 어려움에 대한 이해

최신 웹사이트는 단순 텍스트 기반의 문서형 웹 사이트가 아닌 여러 요소들(검색창, 모달 등)을 담고 있으므로 브라우저에서 제공하는 웹 언어로만으로 구현하기 어려움. 이는 곧, **웹 언어와 사용자 UX간 상당한 격차가 있음을 의미함**

**웹 개발 관점에서 UI 구축**

**이상적인 UI 구성 환경:** UI 디자이너와 같은 환경

대부분의 디자이너들은 Figma, Adobe 디자인툴을 사용하여 캔버스에 드래그&드롭으로 쉽게 UI 요소들을 배치할 수 있지만 웹 개발에서 이렇게 할 수 없음. 간단한 검색창을 만들더라도 해당 요소를 감싸는 요소가 필요하며, 폰트, 크기, 간격등을 수동으로 정의해야함

## 1.2 상태 관리의 이해

프론트엔드에서 상태 관리는 복잡한 구조로 되어 있음

**상태관리 시 고려해야할 사항**

- 비동기 호출 시 **예외 사항을 처리** 해줘야 함
- 데이터를 가져오는 동안 무엇을 화면에 표시해줄지, 서버 또는 네트워크 이슈로 인한 에러 등 다양한 에러 상태에 대해 어떻게 처리해야 할 지 고려해야함
- 애플리케이션이 커지고 복잡해지게 되면 Zustand, Redux등 서드파티 상태관리 라이브러리를 사용해도 좋지만 라이브러리에 대한 학습이 필요하며, 모범 케이스를 연구해야 할 수 있음

## 1.3 예외 흐름 탐색하기

프론트엔드에 복잡성을 높이는 또다른 요인은 바로 **예외 흐름**이다. 일반적으로 UI를 개발 할 때 최적의 사용자 경험을 제공하기 위한 `정상 흐름` 을 우선 고려함. 하지만 `예외 흐름`을 무시하게 될 경우 예상하지 못한 문제를 직면할 수 있다.

그럼 지금부터 예외흐름으로 이어지는 UI 개발 사례를 살펴보자

### 1.3.1 다른 컴포넌트에서 발생한 오류

애플리케이션을 개발하는데 *서드파티 컴포넌트*를 사용한다고 가정해보자. 이 컴포넌트에 문제가 생기면 UI 화면이 망가져 예상하지 못한 문제가 발생할 수 있음 이러한 예외적인 문제를 처리하기 위해 **조건문을 추가하거나 에러 바운더리를 추가해야함** 에러 바운더리를 추가할 때 사용자에게 보여질 대체 화면을 고려해봐야함

실제 프로젝트의 경우 다양한 마이크로 서비스 또는 API에서 데이터를 가져오게 되므로 이 시스템들에 문제가 생겼을 때 UI에서도 이에 대한 준비(대체 디자인, 로딩 표시, 에러 발생에 대한 안내 메세지 등)가 필요함.

### 1.3.2 예측하지 못한 사용자 행동

UI를 완벽하게 설계했더라도 사용자의 예상하지 못한 방식으로 시스템을 사용할 경우 이에 대한 대비할 수 있는 UI를 설계 해야 하는데 예를 들어 유효성 검사 등의 안전 장치를 추가 구현하게 되면 UI는 더욱 더 복잡해질 수 있음.

**예외 흐름을 처리하기 위해선 `예외 흐름`을 이해화 적절한 조치가 필요하다. 이는 견고하고 유연하며 사용자 친화적인 인터페이스를 만드는데 굉장이 중요하다**

## 1.4 리엑트의 일반적인 안티패턴 살펴보기

### 1.4.1 Prop Drilling

- **문제점**
  - prop이 부모 컴포넌트 -> 자식 컴포넌트로 전달될 때 여러개의 불필요한 자식 컴포넌트를 거쳐서 전달하게 되는 `Prop Drilling` 현상이 발생함.
  - 이러한 방식은 복잡도를 높히고 유지보수성을 떨어뜨리며 데이터 흐름을 방해하고 디버깅이 어려워질 수 있음
- **잠재적 해결방법**
  - 리엑트에서 제공하는 Context API를 활용
  - Context API는 컴포넌트 간 직접 데이터와 함수를 공유하는 방법을 제공함

### 1.4.2 컴포넌트 내 데이터 변환

외부 API로부터 받은 데이터를 변환하는 작업을 따로 분리(유틸리티 함수 등)하지 않고 컴포넌트 내에서 변환하는 코드를 작성하는 경우가 있음.

**컴포넌트 내부에서 데이터 변환시 문제점**

- **명확하지 않음**: 데이터 가져오기&변환, 화면 렌더링 등 컴포넌트 내에서 많은 작업들이 진행되므로 해당 컴포넌트가 어떤 역할을 하는지 파악하기 어려움
- **재사용성이 떨어짐**: 다른 컴포넌트에서 유사한 데이터 변환이 필요할 경우 로직 중복 발생
- **테스트하기 어려움**: 테스트에 필요한 변환 로직을 고려해야 하므로 테스트 코드가 복잡해질 수 있음

**데이터 변환 로직을 분리했을 때의 장점**

- 컴포넌트가 렌더링과 비즈니스 로직에 집중 할 수 있음
- 유지보수가 쉬운 코드베이스를 만들 수 있음

### 1.4.3 뷰 영역의 복잡한 로직

리엑트의 장점 중 하나는 역할(관심사)를 명확하게 분리할 수 있음(=컴포넌트). 일반적인 설계상 컴포넌트의 경우 비즈니스 로직을 고려하지 않고 화면 렌더링에 대한 부분에만 집중하여 개발을 해야함. 그러나 종종 컴포넌트안에서 비즈니스 로직까지 구현하는 경우가 있음. 컴포넌트 안에 비즈니스 로직을 구현하게 되면 `1.4.2`에서 다룬것처럼 컴포넌트의 역할이 불명확해지고, 컴포넌트가 복잡해져 테스트 재사용이 어려울 수 있음

**그럼 어떻게 분리하는것이 좋을까?**

- 컴포넌트를 재사용 가능하고 유지보수하기 쉽게 만들기 위해서는 **관심사 분리 원칙**을 지키는것이 좋음
- 각각의 모듈 또는 함수가 각자의 기능에 대한 책임만 가지도록 분리한다면 코드의 각 부분이 명확한 책임을 갖고 모듈화가 되어 관리하기 쉬움

### 1.4.4 테스트 부족

컴포넌트를 완성했다고 해서 끝이 아니라 설계했던 기능들이 정상적으로 구현이 되는지 테스트를 통해 검증해야함.

**TDD(테스트 주도 개발)**
TDD는 테스트 코드를 먼저 작성하고 실제 컴포넌트 로직을 나중에 작성하는것을 권장함. TDD를 통해 오류를 조기에 발견하고 구조화, 유지보수 가능한 코드 작성을 가능하게 함. 애플리케이션이 커지더라도 TDD 테스트 코드가 있다면 구현 코드 수정이나 기능 추가에도 정확성 보장함

### 1.4.5 중복된 코드

애플리케이션이 커지면 유사하거나 동일한 소스코드들이 여기저기 흩어져 있는 경우를 자주 겪게 되는데, 중복코드는 애플리케이션을 불필요하게 부풀릴 뿐만 아니라 예상하지 못한 문제를 야기 시킬 수 있고 버그가 발견되거나 오류가 발생하면 흩어져 있는 모든 중복코드를 일일히 변경해야함

**그럼 중복코드를 제거할 방법은?**
중복 배제 원칙을 활용하여 이를 방지할 수 있음. 공통 로직을 유틸리티 함수 또는 고차 컴포넌트로 모아서 관리하면 컴포넌트의 가독성도 높아지고 유지보수가 용이하며 오류 발생 가능성이 현저히 낮아짐.

### 1.4.6 너무 많은 기능을 가진 컴포넌트

리엑트는 재사용 가능한 모듈형 컴포넌트를 만들도록 권장함. 근데 하나의 컴포넌트에 여러 기능들이 구현되어 있다면 다른 컴포넌트에서 이를 재사용 및 유지보수, 테스트가 어려워질 수 있음. 따라서 **단일 책임 원칙**에 위배되지 않도록 각 컴포넌트의 핵심 기능을 파악해서 부가적인 로직들은 커스텀 훅, 또는 더 작은 단위의 컴포넌트로 분리해야 함

### 1.4.7 안티패턴을 없애기 위한 접근 방식

- #### 다양한 디자인 패턴 활용
  - render prop, 고차 컴포넌트, 훅과 같은 기술을 통해 컴포너넌트가 기본적인 역할에서 벗어나지 않고 그 기능을 강화 할수 있게함
  - 뼈대가 되는 패턴을 활용하면 로직과 데이터, 렌더링을 일관된 방식으로 나누어 코드베이스 간소화 가능
- #### 인터페이스 지향 프로그래밍
  - 인터페이스를 통해 소프트웨어 모듈 간에 발생하는 상호작용 모듈화
  - 모듈화된 운영방식은 소프트웨어 모듈을 쉽게 변경하면서 일관성을 유지할 수 있음
- #### TDD 및 지속적인 리펙토링
  - TDD는 잠재적인 부일치에 대한 즉각적인 피드백 루프 제공
  - 지속적인 리펙토링은 지속적인 코드 체계화 및 개선
