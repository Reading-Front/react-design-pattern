# 리액트 안티패턴 소개

## 목차

- [리액트 안티패턴 소개](#리액트-안티패턴-소개)
  - [목차](#목차)
  - [1.1 UI 구축의 어려움에 대한 이해](#11-ui-구축의-어려움에-대한-이해)
  - [1.2 상태 관리의 이해](#12-상태-관리의-이해)
  - [1.3 예외 흐름 탐색하기](#13-예외-흐름-탐색하기)
      - [다른 컴포넌트에서 발생한 오류](#다른-컴포넌트에서-발생한-오류)
      - [예측하지 못한 사용자행동](#예측하지-못한-사용자행동)
  - [1.4 리액트의 일반적인 안티패턴 살펴보기](#14-리액트의-일반적인-안티패턴-살펴보기)
      - [Prop Drilling](#prop-drilling)
      - [컴포넌트 내 데이터 변환](#컴포넌트-내-데이터-변환)
      - [뷰 영역의 복잡한 로직](#뷰-영역의-복잡한-로직)
      - [테스트 부족](#테스트-부족)
      - [중복된 코드](#중복된-코드)
      - [너무 많은 기능을 가진 컴포넌트](#너무-많은-기능을-가진-컴포넌트)
      - [안티패턴을 없애기 위한 접근 방식](#안티패턴을-없애기-위한-접근-방식)
  - [1.4 리뷰](#14-리뷰)

## 1.1 UI 구축의 어려움에 대한 이해

컴포넌트는 html, js, css로 이루어져있어 사용자마다 해당 디자인에대한 사용자 경험이 다를 수 있음

## 1.2 상태 관리의 이해

서버 상태 관리의 어려움을 요약해보면 아래와 같다

1. 비동기 특성: 원격 데이터 동기화할 때 시간의 순서가 중요
2. 오류 처리: 원격 소스 연결은 때로 실패하거나, 서버에서 오류로 응답 가능
3. 로딩 상태: 데이터 도착까지 로딩 상태를 효과적으로 다루어야함
4. 일관성: 클라와 서버간의 상태를 동기화하는것이 중요
5. 캐싱: 일부 서버 상태를 로컬에 저장하여 성능 향상 시키면 좋음, 이떄 데이터 불일치와 무효화 같은 문제에 유의해야함
6. 업데이트 및 낙관적 UI: 낙관적 업데이트는 좋으나, 서버 응답이 실패할 수 있기 떄문에 FE를 성공 이전의 상태로 되돌릴 수 있는 방법이 필요함

## 1.3 예외 흐름 탐색하기

UI 개발 시 모든것이 정상흐름이면 좋겠지만, 예외 케이스는 항상 존재함
이번 챕터에서는 예외 흐름으로 이어지는 복잡한 UI개발 사례를 소개

#### 다른 컴포넌트에서 발생한 오류

서드파티 컴포넌트 사용할때, 컴포넌트 설계와 다른 규격을 주입 시 에러가 남 이를위해 리액트의 에러 바운더리 기능을 이용해서 fallbackUI 사용하면 좋음

#### 예측하지 못한 사용자행동

sql inject이나 xss같이 사용자들이 예쌍하지 못한 방식으로 시스템을 사용할 수 있음
이러한 예외 흐름에 대한 적절한 예외 처리를 해야 세심한 사용자 경험을 얻을 수 있음

## 1.4 리액트의 일반적인 안티패턴 살펴보기

#### Prop Drilling

리액트에서 props만 사용하여 전달하면 중간 컴포넌트또한 거치게되어 Prop Drilling현상이 나와 좋지 않음

> - 불필요한 리렌더링으로 인한 성능 저한
> - 디버깅 어려움

-> context api or 상태관리 라이브러리 사용

#### 컴포넌트 내 데이터 변환

컴포넌트 내부에서 데이터 변환 시 아래와 같은 이슈가 있음

- 명확하지 않음: 데이터 가져오기와 변환, 렌더링 작업이 하나의 컴포넌트 안에서 이루어지므로 이 컴포넌트가 어떤 역할을 하는지 알기 어려움
- 재사용성이 떨어짐: 다른 컴포넌트에서 유사한 변환이 필요한경우, 로직의 중복이 발생함
- 테스트하기 어려움: 테스트를 하려면 변환 로직을 고려해야 하므로 테스트 코드가 복잫ㅂ해짐

이는 유틸리티 함수나 커스텀 훅을 이용하여 보다 명확하고 모듈화된 구조로 바꾸면 좋음

#### 뷰 영역의 복잡한 로직

설계상 컴포넌트는 비즈니스 로직을 신경쓰지 않고 프리젠테이션에 집중해야함.

이는 테스팅, 재사용성, 유지보수성에 좋지 않음
관심사 분리 원칙을 지키면 좋음, 계층화된 아키텍처를 만들어보자

#### 테스트 부족

테스트 코드가 있어야, 안정성이 높아짐.
TDD는 오류를 조기에 발견할 수 있고, 유지보수 가능한 코드를 작성할 수 있게 해줌.
이게 힘들다면 완성후라도 테스트를 도입할 것

#### 중복된 코드

중복 배제 원칙을 적용하여 공통로직을 빼서 고차 컴포넌트나 유틸함수로 모으면 좋음

#### 너무 많은 기능을 가진 컴포넌트

props로 너무 많은 데이터를 받아오는 등 컴포넌트에서 너무 많은 기능을 담당하면, 단일 책임 원칙에 위배됨
커스텀 훅을 적극 활용

#### 안티패턴을 없애기 위한 접근 방식

render prop, 고차 컴포넌트, 훅과 같은 기술은 컴포넌트가 기본적인 역할에서 벗어나지 않으면서 그 기능을 강화할 수 있음
계층화된 아키텍처와 관심사의 분리처럼 뼈대가 되는 패턴을 활용하여 학습하면 좋음
ex)
**인터페이스 지향 프로그래밍**
인터페이스를 통해 소프트웨어 모듈간에 발생하는 상호작용을 중심으로 소프트웨어를 구성하는데 중정둠 이러한 모듈화된 운영방식은 변경이 쉽고 일관성을 유지할 수 있음
**헤드리스 컴포넌트 패러다임**
렌더링 역할은 없지만, 상태또는 로직을 관리하는 컴포넌트를 구현하는 패턴, 이 패러다임은 컴포넌트에 UI렌더링의 역할을 넘겨주므로 다양한 곳에서 적용할 수 있어 재사용 편리

## 1.4 리뷰

리액트의 보편적인 안티패턴을 소개시켜주며, 앞으로의 방향성을 소개해주는 챕터

고려할것은 인터페이스 지향 프로그래밍을 어떻게 설계할 것 이며, 헤드리스 컴포넌트를 어느정도까지 설계해야하나 고민해보면 좋을 것 같음

TDD에 대한 의견또한 여러의견으로 나뉘지만 보편적으로는 서비스 개발에서는 리소스 대비 효율이 떨어진다는 이야기가 많음, 과거 토론의 결과 피처 완성 후 테스트를 도입하는게 이상적이다 라는 이야기가 지배적이였음

개인적으로 TDD를 하려면 뛰어난 개발자가 있어야 하는게 아닌, 뛰어난 기획자 및 사업부가 있어야한다 생각됨.
