# 1. 리액트 안티패턴 소개

프론트 엔드란 화면에 보여지는 앞단을 의미한다.

웹사이트를 들어가보면 나오는 레이아웃과 UI는 여러 컴포넌트들이 유기적으로 조화를 이루며 만들어진 유기체이다.

UI 만 보면 형체에 가깝기 때문에 실제 데이터와 연동하는 작업이 주요하다고 볼 수 있는데, 여기서 우리가 자주 사용하는 '상태 관리' 개념이 등장한다.

작업의 흐름에 따라 논리적인 사고를 하기 위해서는 동기적인 코드 흐름으로 구현되어야 할 필요가 있다.

1. 비동기 특성 - 데이터 가져오기
2. 오류 처리 - 연결 실패 / 서버 오류
3. 로딩 상태 - 데이터를 가져오는 동안 fallback UI 노출
4. 일관성 - 프론트와 백의 동기화
5. 캐싱 - 일부 서버 상태를 로컬에서 저장해서 성능을 올림 (캐시 무효화, 데이터 불일치 등의 문제 발생 여지 있음)
6. 업데이트 및 낙관적 UI

예를 들어, 책의 예제처럼 인용구를 fetch 로 가져와서 list로 노출하는 예를 생각해보자.

useEffect를 사용해서 fetch 해와야 하고, fetch하는 동안의 로딩 상태(isLoading)도 노출해줘야 한다. 
그리고, fetch에 실패했을때의 UI도 노출해줘야 한다.
대략 구현하면 아래와 같은 형태이다.

```tsx

import React, { useEffect, useState } from "react";

function Quotes() {
    const [quotes, setQuotes] = useState<string[]>([]);
    const [isLoading, setIsLoading] = useState<boolean>(false);
    const [error, setError] = useState<Error | null>(null);

    useEffect(() => {
        setIsLoading(true);
        fetch("https://dummyjson.com/quotes").then((response) => {
            if (!response.ok) {
                throw new Error("Failed to fetch quotes");
            } return response.json();
        })
            .then((data) => {
                setQuotes(data.quotes.map((quote) => quote.quote));
            })
            .catch((err) => { setError(err.message); })
            .finally(() => { setIsLoading(false); });
    }, []);

    return (
        <div>
            {isLoading && <p>Loading...</p>}
            {error && <p>Error: {error.message}</p>}
            <ul>
                {quotes.map((quote, index) => (<li key={index}>{quote}</li>))}
            </ul>
        </div>
    );
};

export default Quotes

```

