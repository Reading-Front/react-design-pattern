# 1. 리액트 안티패턴 소개

프론트 엔드란 화면에 보여지는 앞단을 의미한다.

웹사이트를 들어가보면 나오는 레이아웃과 UI는 여러 컴포넌트들이 유기적으로 조화를 이루며 만들어진 유기체이다.

UI 만 보면 형체에 가깝기 때문에 실제 데이터와 연동하는 작업이 주요하다고 볼 수 있는데, 여기서 우리가 자주 사용하는 '상태 관리' 개념이 등장한다.

작업의 흐름에 따라 논리적인 사고를 하기 위해서는 동기적인 코드 흐름으로 구현되어야 할 필요가 있다.

1. 비동기 특성 - 데이터 가져오기
2. 오류 처리 - 연결 실패 / 서버 오류
3. 로딩 상태 - 데이터를 가져오는 동안 fallback UI 노출
4. 일관성 - 프론트와 백의 동기화
5. 캐싱 - 일부 서버 상태를 로컬에서 저장해서 성능을 올림 (캐시 무효화, 데이터 불일치 등의 문제 발생 여지 있음)
6. 업데이트 및 낙관적 UI

예를 들어, 책의 예제처럼 인용구를 fetch 로 가져와서 list로 노출하는 예를 생각해보자.

useEffect를 사용해서 fetch 해와야 하고, fetch하는 동안의 로딩 상태(isLoading)도 노출해줘야 한다. 
그리고, fetch에 실패했을때의 UI도 노출해줘야 한다.
대략 구현하면 아래와 같은 형태이다.

```tsx

import React, { useEffect, useState } from "react";

function Quotes() {
    const [quotes, setQuotes] = useState<string[]>([]);
    const [isLoading, setIsLoading] = useState<boolean>(false);
    const [error, setError] = useState<Error | null>(null);

    useEffect(() => {
        setIsLoading(true);
        fetch("https://dummyjson.com/quotes").then((response) => {
            if (!response.ok) {
                throw new Error("Failed to fetch quotes");
            } return response.json();
        })
            .then((data) => {
                setQuotes(data.quotes.map((quote) => quote.quote));
            })
            .catch((err) => { setError(err.message); })
            .finally(() => { setIsLoading(false); });
    }, []);

    return (
        <div>
            {isLoading && <p>Loading...</p>}
            {error && <p>Error: {error.message}</p>}
            <ul>
                {quotes.map((quote, index) => (<li key={index}>{quote}</li>))}
            </ul>
        </div>
    );
};

export default Quotes

```

실제 렌더링을 담당하는 코드는 읿부분이고 상태 관리를 위한 코드는 함수 본문의 대부분을 차지한다.

이러한 이유로 hook을 사용하거나, presentation component를 분리해서 관심사를 분리할 수 있다.


## 안티 패턴

### 1. Prop Drilling

props를 사용하지 않는 컴포넌트에서도 부모에서 전달한 props를 더 하위의 자식에게 넘겨주기 위해 props drilling 하는 현상

### 2. 컴포넌트 내 데이터 변환

❌ 안티 패턴

```tsx

function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    // 컴포넌트 안에서 데이터를 직접 fetch하고 변환
    fetch(`/api/users/${userId}`)
      .then(response => response.json())
      .then(data => {
        // 데이터 변환 로직이 컴포넌트 안에!
        const transformedUser = {
          name: `${data.firstName} ${data.lastName}`,
          age: data.age,
          address: `${data.addressLine1}, ${data.city}, ${data.country}`
        };
        setUser(transformedUser);
      });
  }, [userId]);

  return (
    <div>
      <p>Name: {user.name}</p>
      <p>Age: {user.age}</p>
      <p>Address: {user.address}</p>
    </div>
  );
}

```

✅ 개선 사항

```tsx
// 1. 커스텀 훅으로 데이터 로직 분리
function useUser(userId) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchAndTransformUser(userId).then(setUser);
  }, [userId]);
  
  return user;
}

// 2. 컴포넌트는 UI만 담당
function UserProfile({ userId }) {
  const user = useUser(userId);
  
  return (
    <div>
      <p>Name: {user?.name}</p>
      <p>Age: {user?.age}</p>
      <p>Address: {user?.address}</p>
    </div>
  );
}

```

### 3. 뷰 영역의 복잡한 로직

❌ 안티 패턴

```tsx
function PriceListView({ items }) {
  return (
    <div>
      {items.map(item => (
        <div key={item.id}>
          {/* 비즈니스 로직이 JSX 안에! */}
          {item.price > 100 ? (
            <div>
              {item.name}: ${item.price} (비싸요!)
            </div>
          ) : (
            <div>
              {item.name}: ${item.price}
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
```

✅ 개선 사항

```tsx
// 1. 비즈니스 로직 분리
const isExpensive = (price) => price > 100;
const formatPrice = (item) => ({
  ...item,
  displayPrice: `$${item.price}`,
  isExpensive: isExpensive(item.price)
});

// 2. UI는 표시만 담당
function PriceListView({ items }) {
  const formattedItems = items.map(formatPrice);
  
  return (
    <div>
      {formattedItems.map(item => (
        <PriceItem key={item.id} item={item} />
      ))}
    </div>
  );
}

function PriceItem({ item }) {
  return (
    <div className={item.isExpensive ? 'expensive' : 'normal'}>
      {item.name}: {item.displayPrice}
      {item.isExpensive && ' (비싸요!)'}
    </div>
  );
}
```

### 4. 테스트 부족

### 5. 중복된 코드

❌ 안티 패턴

```tsx
// AdminList와 ActiveList가 거의 동일한 구조
function AdminList({ users }) {
  const filteredUsers = users.filter(user => user.isAdmin);
  return <List items={filteredUsers} />;
}

function ActiveList({ users }) {
  const filteredUsers = users.filter(user => user.isActive);
  return <List items={filteredUsers} />;
}
```

✅ 개선 방법

```tsx
// 공통 컴포넌트로 추상화
function FilteredUserList({ users, filterFn, title }) {
  const filteredUsers = users.filter(filterFn);
  return (
    <div>
      <h2>{title}</h2>
      <List items={filteredUsers} />
    </div>
  );
}

// 사용법
<FilteredUserList 
  users={users} 
  filterFn={user => user.isAdmin} 
  title="관리자 목록" 
/>

<FilteredUserList 
  users={users} 
  filterFn={user => user.isActive} 
  title="활성 사용자 목록" 
/>

```

### 6. 너무 많은 기능을 가진 컴포넌트

❌ 안티 패턴

```tsx
// 하나의 컴포넌트가 너무 많은 일을 함!
function OrderContainer() {
  const [items, setItems] = useState([]);
  const [testID, setTestID] = useState('');
  const [orderData, setOrderData] = useState({});
  const [basketError, setBasketError] = useState('');
  const [addCoupon, setAddCoupon] = useState('');
  const [voucherSelected, setVoucherSelected] = useState(false);
  const [validationErrors, setValidationErrors] = useState([]);
  // ... 더 많은 state들
  
  // 장바구니 추가, 제거, 계산, 검증 등 모든 로직이 한곳에!
  const addItem = (item) => { /* ... */ };
  const removeItem = (itemId) => { /* ... */ };
  const calculateTotal = () => { /* ... */ };
  const validateOrder = () => { /* ... */ };
  
  return (
    <div>
      {/* 복잡한 UI */}
    </div>
  );
}

```

✅ 개선 사항

```tsx
// 1. 장바구니 로직만 담당
function useShoppingCart() {
  const [items, setItems] = useState([]);
  
  const addItem = (item) => setItems([...items, item]);
  const removeItem = (itemId) => 
    setItems(items.filter(item => item.id !== itemId));
  const calculateTotal = () => 
    items.reduce((total, item) => total + item.price, 0);
    
  return { items, addItem, removeItem, calculateTotal };
}

// 2. 주문 검증만 담당
function useOrderValidation(orderData) {
  const [errors, setErrors] = useState([]);
  // 검증 로직만...
  return { errors, validateOrder };
}

// 3. UI 컴포넌트는 조합만 담당
function OrderPage() {
  const cart = useShoppingCart();
  const validation = useOrderValidation();
  
  return (
    <div>
      <ShoppingCartView {...cart} />
      <OrderSummary total={cart.calculateTotal()} />
      <ValidationErrors errors={validation.errors} />
    </div>
  );
}
```

📋 핵심 원칙 요약

- 단일 책임 원칙: 컴포넌트는 하나의 역할만 해야 함
- 관심사 분리: UI 로직과 비즈니스 로직을 분리
- 재사용성: 공통 로직은 커스텀 훅이나 유틸 함수로
- 테스트 가능성: 작은 단위로 나누면 테스트하기 쉬움
