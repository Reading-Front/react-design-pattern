# CHAPTER 1: 리액트 안티패턴 소개

## 1. UI 구축의 어려움에 대한 이해

피르마를 사용하여 캔버스에 드래그 앤드 드롭 하듯이 컴포넌트들을 자유롭게 화면에 배치할 수 있으면 좋겠지만, 실제 웹 개발에서는 그럴 수 없다.

웹 UI 개발은 HTML, CSS, 자바스크립트를 이용하는데, 각각 다른 문법과 목적을 갖고 있어 언어 불일치 문제가 있다.

## 2. 상태 관리의 이해

네트워크를 통해 백엔드 서버, API와 같은 외부 소스에서 가져오는 데이터를 서버 상태라 부른다. 이는 프런트엔드 애플리케이션 내에서 생성되고 관리되는 로컬 상태와는 다르다.

서버 상태를 다룰 경우 다음과 같은 것들을 고려해야 한다.

- 비동기 특성 : 원격 소스에서 데이터를 가져오는 것은 일반적으로 비동기 작업이다. 특히 여러 원격 데이터를 동기화할 때 시간의 순서가 중요하다.
- 오류 처리 : 원격 소스 연결은 때로는 실패하거나, 서버에서 오류를 응답할 수 있다.
- 로딩 상태 : 원격 소스에서 데이터가 도착하기를 기다리는 동안 애플리케이션은 로딩 중 상태를 효과적으로 다뤄야 한다. 로딩 표시기 또는 실패 fallback UI를 표시한다.
- 일관성 : 프런트엔드 상태를 백엔드와 동기화 하는 것을 의미한다.
- 캐싱 : 일부 서버 상태를 로컬에 저장하면 성능을 향상시킬 수 있지만, 데이터 불일치와 무효과 같은 문제가 생길 수 있다.
- 업데이트 및 낙관적 UI : 사용자가 상태를 변경했을 때 서버 호출이 성공할 것이라고 예측하고, 서버 응답이 오기 전에 미리 업데이트하여 더 나은 사용자 경험을 제공할 수 있다. 하지만 서버 응답 실패시 성공 이전의 상태로 되돌릴 수 있어야 한다.

프런트엔드에서 데이터를 즉시 저장하고 접근할 수 있다면, 개발자는 순차적 사고를 할 수 있다. 작업의 흐름에 따라 데이터에 접근하고 조작하므로 명확하고 순차적인 논리의 흐름으로 이어진다.

원격 데이터를 추가로 렌더링하려면 위의 고려사항들을 주의해야 한다. 비동기로 데이터를 가져오고, 서버 상태, 로딩 상태, 오류 상태를 관리해야 한다. 애플리케이션이 복잡해져서 상태를 관리하기 힘든 수준이 된다면, Context API, 서드파티 상태 관리 라이브러리를 사용하는 것이 도움될 수 있다.

## 예외 흐름 살펴보기

프론트엔드의 복잡도를 높이는 또 다른 요인으로 예외 흐름(unhappy path)이 있다. <br />
UI를 개발할 떄 모든 것이 계획한 대로 최적의 사용자 경험을 제공하는 '정상 흐름(happy path)' 을 우선 고려한다. 하지만 '예외 흐름'을 무시하고 개발한 UI 컴포넌트는 생각보다 힘든 상황을 불러올 수 있다.

예외 흐름으로 이어지는 복잡한 UI 개발 사례를 소개한다.

### 다른 컴포넌트에서 발생한 오류

서드 파티 컴포넌트에서 오류가 발생하면, UI 화면을 망가뜨리거나 예상하지 못한 동작이 일어날 수 있다.
오류를 에러 바운더리로 격리시키지 않는다면, 전체 애플리케이션 충돌로 이어질 수 있다.
에러 바운더리는 자식 컴포넌트의 자바스크립트 오류를 잡아서 로그를 기록하고 애플리케이션 전체가 충돌하지 않도록 fallback UI를 표시한다. 에러 바운더리는 렌더링 과정, 생명주기 메서드, 하위 트리 컴포넌트 생성자에서 발생하는 에러를 포착한다. 이와 같은 처리를 위해 조건문이나 에러 바운더리를 추가해야 하므로 처음 예상보다 UI 코드가 더 복잡해질 수 있다. 대체 디자인, 로딩 표시기, 오류 발생시 안내 표시와 사용자를 위한 안내 문구 등이 필요하다. 이러한 시나리오를 효과적으로 처리하기 위해서는 프런트엔드뿐만 아니라 백엔드 로직까지도 수정해야 할 수 있으므로 UI 개발은 더 복잡해진다.

### 예측하지 못한 사용자 행동

아무리 UI를 완벽하게 설계하더라도 사용자는 항상 예상하지 못한 방식으로 시스템을 사용한다.
텍스트 필드에 특수문자를 입력하거나, form을 너무 빨리 submit하는 등의 엣지 케이스에 대비할 수 있는 UI를 설계하기위해 유효성 검사와 안전 장치를 위해 추가 구현을 하다 보면 UI 코드는 더 복잡해진다.

예외 흐름에 대한 이해와 적절한 처리는 견고하고 유연하며 사용자 친화적인 인터페이스를 만드는 데 매우 중요하다.

## 리액트의 일반적인 안티패턴 살펴보기

소프트웨어 개발 영역에서는 언뜻 보기에 특정 문제에 대한 유익한 해결책처럼 보이는 관행과 접근 방식을 자주 접하게 된다. 안티패턴이라불리는 이러한 관행들은 문제를 빠르게 해결해주는 것 같지만 사실 근본적인 문제를 이면에 숨기는 경우가 많다. 안티패턴에 의존할수록 코드는 더 복잡해지고 효율이 떨어지며, 심지어 해결된 줄 알았던 문제가 더 커지기도 한다.이러한 안티패턴을 이해하고 인식하면 개발자가 마주할 수 있는 함정을 미리 예상하고 장기적으로 생산성을 저해하는 솔루션을 피할수 있다.

### Props Drilling

복잡한 리액트 애플리케이션에서 모든 컴포넌트가 필요한 데이터에 접근할 수 있도록 상태를 관리하는 것은 어려울 수 있다. prop이 부모 컴포넌트에서 자식 컴포넌트로 전달될 때 여러 개의 중간 컴포넌트를 거쳐서 전달하게 되는 Prop Drilling 현상이 나타나기 때문이다. 여러 개의 prop이 여러 컴포넌트를 통해 전달되면 데이터 흐름에 대한 이해를 방해하고 디버깅하기 어려워질 수 있다.

이에 대한 잠재적인 해결책은 리액트에서 제공하는 Context API를 활용하는 것이다. Context API는 컴포넌트 트리의 모든 단계마다 prop을 명시적으로 전달할 필요 없이, 컴포넌트 간에 직접 데이터와 함수를 공유하는 방법을 제공한다.

### 컴포넌트 내 데이터 변환

리액트에서 컴포넌트 중심의 접근 방식은 작업과 문제를 다루기 쉬운 단위로 나눠서 유지보수성을 높여준다.
그러나 흔한 실수 중 하나는 컴포넌트 내부에 복잡한 데이터 변환 로직을 직접 작성하는 것이다.

특히 외부 API나 백엔드에서 전달받은 데이터는 프런트엔드에 적합하지 않은 형태인 경우가 많다. 이러한 데이터를 고차 컴포넌트 또는 유틸리티 함수를 통해 처리하기보다는 컴포넌트 안에서 변환 작업을 수행하는 경우가 많다.

```tsx
function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState<User | null>(null)

  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then((response) => response.json())
      .then((data: RemoteUser) => {
        // Transforming data right inside the component
        const transformedUser = {
          name: `${data.firstName} ${data.lastName}`,
          age: data.age,
          address: `${data.addressLine1}, ${data.city}, ${data.country}`,
        }
        setUser(transformedUser)
      })
  }, [userId])

  return (
    <div>
      {user && (
        <>
          <p>Name: {user.name}</p>
          <p>Age: {user.age}</p>
          <p>Address: {user.address}</p>
        </>
      )}
    </div>
  )
}
```

fetch를 통해 가져온 원격 데이터는 컴포넌트 내에서 변환되어 구조화된 사용자 프로필을 만든다.

컴포넌트 내부에서 데이터 변환 로직을 직접 구현하면 다음과 같은 문제가 발생한다.

- 명확하지 않음 : 데이터 가져오기와 변환, 렌더링 작업이 하나의 컴포넌트 안에서 이루어지므로 이 컴포넌트가 어떤 역할을 하는지 알기 어렵다.
- 재사용성이 떨어짐 : 다른 컴포넌트에서 유사한 변환이 필요한 경우, 로직의 중복이 발생한다.
- 테스트하기 어려움 : 테스트를 하려면 변환 로직을 고려해야 하므로 테스트 코드가 더 복잡해진다.

이러한 안티패턴을 방지하려면 데이터 변환 로직을 컴포넌트와 분리하는 것이 좋다.
이는 유틸리티 함수나 사용자 저의 훅을 이용하여 보다 명확하고 모듈화 된 구조로 바꿔준다. <br />
변환 로직을 컴포넌트 외부로 분리하면, 컴포넌트는 렌더링과 비즈니스 로직에 집중할 수 있으므로 더욱 유지보수하기 쉬운 코드베이스를 만들 수 있다.

### 뷰 영역의 복잡한 로직

리액트와 같은 최신 프런트엔드 프레임워크의 장점 중 하나는 관심사를 명확하게 분리할 수 있게 해준다는 점이다. 설계상 컴포넌트는 비즈니스 로직을 신경 쓰지 않고 프레젠테이션에 집중해야 한다. 그러나 개발자들은 뷰 컴포넌트 안에서 비즈니스 로직을 다루는 함정에 종종 빠지기 쉽다. 이는 깔끔한 관심사 분리를 방해할 뿐만 아니라, 컴포넌트가 크고 복잡해져서 테스트와 재사용을 어렵게 한다.

```tsx
function PriceListView({ items }: { items: Item[] }) {
  // Business logic within the view
  const filterExpensiveItems = (items: Item[]) => {
    return items.filter((item) => item.price > 100)
  }

  const expensiveItems = filterExpensiveItems(items)

  return (
    <div>
      {expensiveItems.map((item) => (
        <div key={item.id}>
          {item.name}: ${item.price}
        </div>
      ))}
    </div>
  )
}
```

이 컴포넌트는 데이터를 표시하는 것뿐만 아니라 가공하는 작업도 수행하는데, 다음과 같은 문제가 있다.

- 재사용성 : 다른 컴포넌트에서 유사한 필터가 필요한 경우, 로직이 중복된다.
- 테스팅 : 렌더링뿐만 아니라 비즈니스 로직도 테스트해야 하므로 단위 테스트가 복잡해진다.
- 유지보수성 : 애플리케이션이 커지면서 더 많은 로직이 추가되기 때문에 유지보수하기 어려워진다.

컴포넌트를 재사용 가능하고 유지보수하기 쉽게 만들기 위해서는 관심사 분리 원칙을 지키는 것이 좋다. 각각의 모듈 또는 함수가 애플리케이션의 하나의 기능에 대한 책임만 가져야 한다는 것이다. 계층화된 아키텍처를 통해 비즈니스 로직과 프레젠테이션 계층을 분리하면, 코드의 각 부분이 명확한 책임을 맡게 되어 보다 모듈화되고 관리하기 쉬운 코드베이스를 구축할 수 있다.

### 테스트 부족

온라인 쇼핑의 장바구니를 만든다고 가정한다. 장바구니는 계속해서 변화하는 영역과 여러 개발 로직으로 교차하는 부분을 잘 구현해 주어야 한다. 테스트가 없다면 가격의 불일치, 아이템이 제대로 담기지 않거나 삭제되지 않는 상황, 심지어 보안 취약성 문제가 발생할 수도 있다.

테스트 주도 개발(TDD)는 테스트 코드를 먼저 작성하고, 실제 컴포넌트 로직을 나중에 작성하는 것을 권장한다. 장바구니의 경우 아이템이 올바르게 추가 또는 제거되는지, 총 결제 금액이 적절하게 바뀌는지, 할인 적용과 같은 특별한 경우도 잘 대응하는지 등을 확인하는 테스트를 수행한다. 이러한 테스트 코드 작성을 완료한 후에 실제 컴포넌트 로직을 구현한다.

TDD는 오류를 조기에 발견하는 것에 그치지 않고 잘 구조화되고 유지보수 가능한 코드 작성을 가능하게 한다. 애플리케이션이 커지더라도 TDD 테스트 코드가 있다면 구현 코드 수정이나 기능 추가에도 정확성을 보장한다.

### 중복된 코드

코드베이스에서 유사하거나 동일한 코드 조각이 애플리케이션의 여러 부분에 흩어져 있는 것은 흔하게 볼 수 있다. 중복 코드는 코드베이스를 부풀릴 뿐만 아니라, 잠재적인 문제를 가져올 수 있다. 버그가 발견되어 개선이 필요할 때, 각각의 중복된 코드 모두를 변경해야 하므로 오류가 발생할 가능성이 높아진다.

**중복 배제(Don't repeat yourself) 원칙**
공통 로직을 유틸리티 함수나 고차 컴포넌트로 모아서 관리하면, 유지보수하기 편하고 가독성이 높은 코드가 되며 오류 발생 가능성이 줄어든다. 이 예제에서 필터링 로직을 추출, 재사용하여 단일 진실 공금원으로 만들어 쉬운 변경을 가능하게 할 수 있다.

> [촉촉한 코드, 건조한 코드](https://velog.io/@gomjellie/The-Wet-Codebase)

### 너무 많은 기능을 가진 컴포넌트

리액트는 재사용 가능한 모듈형 컴포넌트를 만들도록 권장한다. 그러나 기능이 늘어나면 컴포넌트는 맡게 되는 책임이 늘어나면서 다루기 힘든 거대한 덩어리로 변할 수 있다. 다양한 기능을 가진 컴포넌트는 이해하기도, 유지보수하기도, 테스트하기도 어렵다.
여러 개의 역할을 수행하면 더 복잡해지고 유지보수하기 힘들어진다. 컴포넌트의 핵심 기능을 분석하고 부가적인 지원 로직들을 더 작고 집중된 컴포넌트나 훅으로 분리해야 한다.

### 안티패턴을 없애기 위한 접근 방식

널리 퍼져 있는 안티패턴을 해결하기 위해서는 다양한 디자인 패턴을 활용해야 한다.
render prop, 고차 컴포넌트, 훅과 같은 기술은 컴포넌트가 기본적인 역할에서 벗어나지 않으면서도 그 기능을 강화할 수 있게 한다.
**계층화된 아키텍처**와 **관심사의 분리**처럼 뼈대가 되는 패턴을 활용하면 로직과 데이터, 프레젠테이션을 일괄된 방식으로 나누어 코드베이스를 간소화할 수 있다. 이러한 방법론은 리액트 애플리케이션의 지속가능성을 높일 뿐만 아니라 개발자들의 효과적인 팀워크를 위한 기반을 마련한다.

**인터페이스 지향 프로그래밍**은 주로 인터페이스를 통해 소프트웨어 모듈 간에 발생하는 상호작용을 중심으로 소프트웨어를 구성하는 데 중점을 둔다. 이러한 모듈화된 운영 방식은 소프트웨어 모듈을 쉽게 변경하면서 동시에 일관성을 유지할 수 있게 해준다.
반면에 **헤드리스 컴포넌트** 패러다임은 직접적인 렌덜이 역할은 없지만 상태 또는 로직을 관리하는 컴포넌트를 구현한다. 이 패러다임은 사용하는 컴포넌트에 UI 렌더링의 역할을 넘겨주므로 다양한 곳에 적용할 수 있어 재사용하기 편리하다.

**디자인 패턴**을 확실하게 이해하고 적용함으로써 흔한 실수를 예방하여 리액트 애플리케이션의 품질을 높일 수 있다. 또한 TDD와 지속적인 리팩터링은 코드 품질을 높이는 강력한 도구이다. **TDD**는 잠재적인 불일치에 대한 즉각적인 피드백 루프를 제공하고, 지속적인 **리팩터링**은 코드를 계속해서 최적화하고 개선시킵니다. 이러한 방법론은 코드 품질의 우수성을 보장하며, 미래의 코드 변경에 유연하게 대응할 수 있게 합니다.
리팩터링 영역을 공부할 때는 이러한 기술의 본질을 파악하고 가장 효과적인 지점을 찾아 적용하는 것이 중요합니다. 리팩터링 방법을 활용하여 코드의 명확성, 지속 가능성 및 전반적인 효율성을 강화할 수 있습니다.
