# 2장 리액트 필수 개념 이해

## 2.1 리액트 정적 컴포넌트

### 📌 Summary
리액트 컴포넌트는 UI를 구성하는 가장 기본적인 단위.
정적 컴포넌트는 props나 state 없이 단순하게 JSX를 반환하여 항상 동일한 UI를 보여주는 컴포넌트를 말한다.
이들은 UI의 가장 작은 조각들을 정의하는 데 사용되며, 재사용성이 높고 예측 가능하다.

### 🧪 Discusstion Point
Q. 정적 컴포넌트의 장점은 무엇인가요?
A. 정적 컴포넌트는 입력(props)이나 내부 상태(state)가 없기 때문에 항상 동일한 UI를 렌더링해요. 
덕분에 코드가 간결하고 디버깅하기 쉽습니다. 
UI를 작은 단위로 쪼개는 연습을 할 때 기초가 되는 컴포넌트라고 볼 수 있어요.

```tsx
import React from 'react';

const StaticComponent = () => {
  return <div>Hello, I am a static component!</div>;
};

export default StaticComponent;
```

## 2.2 prop가 있는 컴포넌트 만들기

### 📌 Summary
컴포넌트에 데이터를 전달할 때는 **Props(Properties)**를 사용한다. 
Props는 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 역할을 하며, 이 과정에서 컴포넌트는 동적인 UI를 생성할 수 있습니다. 
Props는 **변경 불가능한(immutable) 읽기 전용 데이터**이다.

### 🧪 Discusstion Point
Q. Props를 사용하면 어떤 점이 좋나요?
A. Props를 사용하면 컴포넌트를 재사용하기 쉬워져요. 
예를 들어, Card 컴포넌트를 만들고, props로 제목, 내용, 이미지를 전달해주면 여러 곳에서 다양한 내용을 가진 Card를 만들 수 있죠. 
또한 리액트의 핵심 원칙인 **단방향 데이터 흐름(One-way Data Flow)**을 지킬 수 있어요.

```tsx
import React from 'react';

const PropsComponent = ({ name }) => {
  return <div>Hello, {name}!</div>;
};

export default PropsComponent;
```

## 2.3 UI를 여러 컴포넌트로 나누기

### 📌 Summary
복잡한 UI는 하나의 거대한 컴포넌트로 만들기보다는, 여러 개의 작고 재사용 가능한 컴포넌트로 나누는 것이 좋다.
이를 **컴포넌트 분리(Component Separation)**라고 하며, 각 컴포넌트가 하나의 역할만 담당하게 만들어 코드의 가독성과 유지보수성을 높일 수 있다.

### 🧪 Discusstion Point
Q. 컴포넌트를 나눌 때 기준은 무엇인가요?
A. 가장 좋은 기준은 **단일 책임 원칙(Single Responsibility Principle_SRP)**이에요. 
한 컴포넌트가 한 가지 역할만 하도록 나누는 거죠. 
예를 들어, 사용자 프로필 화면을 만들 때 `UserProfile` 컴포넌트 하나에 모든 것을 담기보다, `ProfileImage`, `UserInfo`, `FollowButton` 등으로 나누는 것이 더 효과적입니다.

- `UserProfile.tsx`
```tsx
import React from 'react';
import ProfileImage from './ProfileImage';
import UserInfo from './UserInfo';

const UserProfile = () => {
  return (
    <div>
      <ProfileImage />
      <UserInfo name="John Doe" email="john.doe@example.com" />
    </div>
  );
};

export default UserProfile;
```
- `ProfileImage.tsx`
```tsx
import React from 'react';

const ProfileImage = () => {
  return <img src="https://placehold.co/100x100" alt="Profile" />;
};

export default ProfileImage;
```

- `UserInfo.tsx`
```tsx
import React from 'react';

const UserInfo = ({ name, email }) => {
  return (
    <div>
      <h3>{name}</h3>
      <p>{email}</p>
    </div>
  );
};

export default UserInfo;
```

## 2.4 리액트 내부 상태 관리

### 📌 Summary
**상태(State)**는 시간에 따라 변할 수 있는 데이터를 의미하며, 컴포넌트의 렌더링에 영향을 준다. 
리액트에서는 useState 훅을 사용하여 상태를 관리한다. 
useState는 상태 값과 상태를 업데이트하는 함수를 배열로 반환하며, 이 함수를 통해 상태를 변경해야만 리액트가 컴포넌트를 다시 렌더링합니다.

### 🧪 Discusstion Point
Q. 상태를 직접 변경하면 안 되는 이유는 무엇인가요?
A. state를 직접 변경하면 리액트가 상태가 바뀌었다는 것을 인지하지 못해서 리렌더링을 하지 않아요. 
항상 useState가 반환하는 업데이트 함수를 사용해서 상태를 변경해야만 리액트가 새로운 상태를 감지하고, 컴포넌트를 효율적으로 다시 렌더링할 수 있습니다.

```tsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  const increment = () => {
    setCount(count + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}

export default Counter;
```

## 2.5 렌더링 과정 이해하기

### 📌 Summary
리액트의 렌더링은 컴포넌트가 화면에 UI를 그리는 과정이다. 
Props나 State가 변경되면 리액트는 해당 컴포넌트를 다시 렌더링한다. 
이때 리액트는 Virtual DOM을 사용하여 변경된 부분만 실제 DOM에 적용하는 재조정(Reconciliation) 과정을 거친다. 
이 덕분에 불필요한 DOM 조작을 최소화하여 성능을 최적화할 수 있습니다.

### 🧪 Discusstion Point
Q. 불필요한 리렌더링을 방지하기 위해서는 어떻게 해야 하나요?
A. React.memo를 사용해서 Props가 변하지 않았을 경우 리렌더링을 막을 수 있어요. 
또한, useCallback과 useMemo 훅을 사용해 불필요한 함수나 값의 재생성을 막는 것도 좋은 방법입니다. 
이들을 적절히 사용하면 성능 최적화에 큰 도움이 됩니다.

```tsx
import React, { useState } from 'react';
import ChildComponent from './ChildComponent';

const ParentComponent = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>Parent Component</h1>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <ChildComponent message="I am a child" />
    </div>
  );
};

export default ParentComponent;
```

```tsx
import React from 'react';

const ChildComponent = ({ message }) => {
  console.log('ChildComponent is rendering!');
  return <div>{message}</div>;
};

export default React.memo(ChildComponent);
```

## 2.6 많이 사용되는 리액트 훅

### 📌 Summary
Hooks는 함수 컴포넌트에서 상태 관리(useState)나 부수 효과(useEffect)와 같은 리액트의 기능을 사용할 수 있게 해주는 특별한 함수들이다. 
이 외에도 컴포넌트의 로직을 재사용 가능한 단위로 분리할 수 있게 해주는 커스텀 훅 등 다양한 훅이 존재한다.

### 🧪 Discusstion Point
Q. useEffect와 useLayoutEffect의 차이점은 무엇인가요?
A. useEffect는 컴포넌트 렌더링 이후에 비동기적으로 실행되는 반면, useLayoutEffect는 DOM이 업데이트된 후 동기적으로 실행돼요. 
따라서 useLayoutEffect는 DOM을 직접 조작하거나, DOM 측정값을 기반으로 하는 레이아웃 관련 작업을 할 때 주로 사용합니다.

```tsx
import React, { useState, useEffect } from 'react';

function HooksExample() {
  const [data, setData] = useState(null);

  useEffect(() => {
    // API 호출과 같은 부수 효과를 여기서 처리
    fetch('[https://jsonplaceholder.typicode.com/todos/1](https://jsonplaceholder.typicode.com/todos/1)')
      .then((response) => response.json())
      .then((json) => setData(json));
  }, []); // 빈 배열: 최초 1회만 실행

  return (
    <div>
      {data ? (
        <div>
          <h2>Data fetched:</h2>
          <pre>{JSON.stringify(data, null, 2)}</pre>
        </div>
      ) : (
        <p>Loading...</p>
      )}
    </div>
  );
}

export default HooksExample;
```

