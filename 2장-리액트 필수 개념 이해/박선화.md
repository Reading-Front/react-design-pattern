# 2장 리액트 필수 개념 이해

## 1. 리액트 정적 컴포넌트

정적 컴포넌트란 상태가 없고 외부 데이터 또는 이벤트에 반응하지 않는 컴포넌트입니다.
프레젠테이션 컴포넌트 또는 더미 컴포넌트라고도 합니다.

```tsx
const StaticArticle =()=>{
  return (
    <article>
      <h3>Think in components</h3>
      <p>It's important to change your mindset when coding with React</p>
    </article>
  )；
}；
```

## 2. prop이 있는 컴포넌트

리액트에서 컴포넌트는 prop이라 불리는 속성으로 입력값을 받을 수 있습니다. 부모 컴포넌트는 자식 컴포넌트에게 prop을 통해 데이터를 전달할 수 있고, 자식 컴포넌트는 다양한 형태의 prop을 정의하여 전달받을 수 있습니다. <u>이를 통해 컴포넌트의 동작과 렌더링 형태를 다양하게 할 수 있고, 자식 컴포넌트의 재사용성을 높이며, 여러 컴포넌트를 조합하여 사용할 수 있습니다.</u>

prop은 자바스크립트 객체이며 키와 값으로 구성되어 있습니다. 키는 prop의 이름을 의미하고 값은 이름에 대응하는 데이터입니다. prop에는 자바스크립트에서 값으로 표현할 수 있는 문자, 숫자, 불리언, 함수까지 다양한 유형의 데이터를 담을 수 있습니다.

컴포넌트 prop은 자바스크립트 객체이므로 속성 개수의 기술적인 제한은 없습니다. 하지만 관리하기 쉬운 컴포넌트를 만들고자 한다면 prop 속성은 가능하면 5, 6개를 넘지 않는 것이 좋습니다. prop 속성의 수가 적을수록 컴포넌트 코드를 유지보수하기 쉽고 이해하기 쉽게 작성할 수 있습니다. 너무 많은 prop 속성은 컴포넌트 로직을 이해하기 어렵게 만들고, 추가 기능구현을 까다롭게 합니다.

## 3. UI를 여러 컴포넌트로 나누기

리액트에서 컴포넌트에 대한 개념과 구조를 파악하면, 애플리케이션의 전반적인 기능성과 구성을 향상시키는 동적이고 재사용성 높은 UI 요소를 만들 수 있습니다. 리액트 개발에 익숙해질수록 스타일링을 통해 시각적인 품질을 높이고, 효율적인 상태 관리를 통해 컴포넌트의 성능과 상호작용성을 높이는 것이 중요합니다.

복잡한 UI를 만들기 위해서는 컴포넌트를 다루기 쉬운 작은 단위로 나누는 것이 중요합니다.
각각의 컴포넌트는 서로 다른 기능을 표시하고, JSX를 통해 컴포넌트들을 조합하여 구성합니다. prop은 컴포넌트 사이에 데이터를 전달하기에 유용하지만, 컴포넌트 내부에서 데이터를 유지해야 하는 상황도 있습니다. 이때 컴포넌트 내부에 데이터를 관리해 주고 업데이트해 주는 상태가 필요합니다.

## 4. 리액트 내부 상태 관리

### 컴포넌트 상태 관리

리액트는 상태를 통해 컴포넌트 내부 데이터를 보관하고 관리할 수 있습니다. 컴포넌트는 상태에 정보를 저장하고 업데이트하여 사용자와 상호작용하는 동적인 ui를 표현할 수 있습니다.

애플리케이션은 다양한 상태를 정의할 수 있는데 토글을 나타내는 불리언 상태. 네트워크 요청을 표시하는 로딩 상태, 사용자가 입력한 질의를 표현하는 문자열 등의 상태가 있습니다.

리액트 훅은 리액트 16.8 버전부터 소개된 기능으로. 함수형 컴포넌트에서도 상태를 관리하고 컴포넌트 생명주기를 다룰 수 있습니다.
useState 혹을 사용하면 컴포넌트 리렌더링이 발생하더라도 내부의 상태를 유지할 수 있으며, 컴포넌트 내부 상태를 관리하기에 좋습니다.

### 전역 레벨 상태 관리

애플리케이션이 커질 수록 부모 컴포넌트에서 자식 컴포넌트로 prop을 통해 데이터를 전달하는 것과 유사하게, 전역 레벨의 데이터를 하위 컴포넌트와 공유할 수 있어야 합니다.

## 5. 렌더링 과정 이해하기

prop이나 상태값 등 컴포넌트가 참조하는 데이터가 바뀌면, 변경 사항을 반영하기 위해 리액트는 UI를 업데이트해야 합니다. 이 과정을 렌더링이라 하며 다음과 같은 단계를 거칩니다.

- 초기 렌더링: 함수 컴포넌트가 처음 렌더링 된 이후에, 컴포넌트의 UI를 표현하는 가상의 객체를 생성합니다. 이 가상 객체는 UI 요소의 구조와 내용을 담고 있습니다.
- 상태와 prop의 변화: 컴포넌트의 상태와 prop이 변경되면 리액트는 함수 컴포넌트를 다시 호출합니다. 이 과정에서 리액트는 변경 전 함수의 실행 결과와 현재의 실행 결과를 비교(diffing)하는 알고리즘을 수행합니다.

> 리액트는 내부에 있는 비교(diffing) 알고리즘을 통해 데이터 변경 전후의 가상 DOM(Document Object Model)의 표현 객체룔 비교하여. 실제 DOM 변경을 최소화하는 방법을 찾습니다.

- 재조정(reconciliation)： 리액트는 비교 과정을 통해 어떤 UI 요소의 업데이트가 필요한지 결정합니다. 변화가 필요한 부분의 UI만을 업데이트하며, 그 외 요소는 변하지 않습니다.
- 리렌더링 : 리액트는 가상 UI 요소를 업데이트하는 방식으로 리렌더링을 수행합니다. 함수의 실행 결과에 따라 이전의 가상 DOM을 새로운 가상 DOM으로 바꿉니다.
- DOM 업데이트: 리액트는 실제 DOM에 효율적으로 가상 DOM의 변경 사항을 반영합니다. 추가, 삭제, 요소 업데이트와 같은 DOM 조작을 통해 상태와 UI에 prop과 상태 변경 사항을 반영합니다.

## 6. 많이 사용되는 리액트 훅

### useState

하나의 컴포넌트 안에서 필요한 만큼의 상태를 정의할 수 있습니다. useState 혹을 사용하면 컴포넌트 리렌더링이 발생하더라도 내부의 상태를 유지할 수 있으며, 컴포넌트 내부 상태를 관리하기에 좋습니다.

### useEffect

리액트에서 **부수 효과**는 컴포넌트 렌더링과 직접 관련되진 않지만, 컴포넌트 바깥 스코프에 영향을 주는 코드를 말합니다. 부수 효과는 API 요청, （리액트의 가상 DOM과는 다른）DOM 수정, 이벤트 리스너 구독, 타이머 사용 등 <u>외부 리소스와의 상호작용</u>과 관련이 있습니다.

리액트는 기본으로 제공되는 useEffect 훅을 통해 **함수 컴포넌트 내의 부수 효과를 관리**합니다. useEffect 훅은 컴포넌트가 렌더링된 이후나 지정된 의존성이 변경될 때 부수 효과를 실행합니다.

useEffect 훅을 통해 부수 효과가 컴포넌트 생명주기에서 적절한 횟수만큼 실행될 수 있도록 합니다. 이런 특성으로 부수 효과와 주요 렌더링 로직을 분리할 수 있으며 애플리케이션의 일관성과 무결성을 유지해줍니다.

<details>
<summary>[useEffect](https://react.dev/reference/react/useEffect)</summary>

```tsx
useEffect(setup, dependencies?)
```

useEffect is a React Hook that lets you synchronize a component with an external system. (useEffect는 컴포넌트를 외부 시스템과 동기화할 수 있는 React Hook입니다.)

setup 함수는 선택적으로 cleanup 함수를 반환할 수도 있습니다. 컴포넌트가 DOM에 추가되면 React는 setup 함수를 실행합니다. 변경된 dependencies로 다시 렌더링할 때마다 React는 먼저 이전 값으로 cleanup 함수를 실행한 다음 새 값으로 setup 함수를 실행합니다. 컴포넌트가 DOM에서 제거된 후 React는 cleanup 함수를 실행합니다.

dependencies는 setup 코드 내에서 참조된 모든 반응형 값의 목록입니다. (린터는 Effect의 dependencies는에 모든 반응형 값을 포함했는지 확인합니다.) 반응형 값에는 props, state, 컴포넌트 본문에서 직접 선언한 모든 변수와 함수가 포함됩니다. React는 Obejct.is 비교를 사용하여 각 종속성을 이전 값과 비교합니다.

의존성 배열이 빈 배열인 경우 컴포넌트가 처음 마운트될 때만 실행되며, dependencies 인수를 생략하면 컴포넌트를 다시 렌더링할 때마다 Effect가 다시 실행됩니다.

</details>

useEffect의 첫 번쨰 인자는 부수 효과를 발생시키는 콜백 함수입니다. 두 번째 인자는 부수 효과를 발생시킬지 결정하는 의존성 변수 배열입니다. 두 번째 인자를 빈 배열로 전달할 경우, 부수 효과가 초기 렌더링 과정에서 한 번만 실행되어야 함을 의미합니다.

개발 환경에서 리액트의 strict-mode를 사용하면. 리액트는 실제 설정 이전에 설정과 정리를 한 번 더 실행합니다. 리렌더링을 수행하여 순수하지 않은 렌더링1 에서 발생할 수 있는 버그를 사전에 확인할 수 있습니다.

useEffect 훅의 부수 효과 처리를 위한 핵심 기능은 정리 함수 동작 방식입니다. useEffect를 사용할 때는 컴포넌트가 마운트 해제될 때 리액트가 호출할 정리 함수를 반환하는 것이 좋습니다. 예를 들어 useEffect 안에서 타이머를 설정했다면, 이 타이머를 해제하는 함수를 반환값으로 제공해야 합니다. 이렇게 함으로써 적절한 리소스 관리와 애플리케이션의 메모리 누수의 위험을 예방할 수 있습니다.

#### [예제] 타이머 사용

```tsx
const Timer = () => {
  useEffect(() => {
    const timerId = setTimeout(() => {
      console.log('time is up')
    }, 1000)

    return () => {
      clearTimeout(timerId)
    }
  }, [])

  return <div>Hello timer</div>
}
```

#### [예제] API 호출

```tsx
useEffect(() => {
  const controller = new AbortController()
  const signal = controller.signal

  const fetchArticleDetail = async (id: string) => {
    fetch('/api/articles/${id}', { signal })
      .then((res) => res.json())
      .then((data) => setArticle(data))
  }
  fetchArticleDetail(id)

  return () => {
    controller.abort()
  }
}, [id])
```

useEffect 훅 안에서 네트워크 요청에 대한 생명주기 관리를 위해 AbortController가 사용되었습니다. 컴포넌트가 마운트되면 useEffect 혹을 통해 AbortController 인스턴스가 생성되고 signal을 참조합니다. 이 signal은 fetch 함수에 전달되고, 컨트롤러의 요청과 연결됩니다.

네트워크 요청 완료 이전에 컴포넌트가 언마운트되면. 컨트롤러의 abort 메서드를 사용하여 수행 중인 네트워크 요청을 취소하는 정리 함수가 호출됩니다. 이를 통해 언마운트된 컴포넌트의 상태를 업데이트하는 등의 잠재적인 이슈를 방지하고, 메모리 누수를 예방하며 더 나은 성능을 보장합니다.

### useCallback

리액트에서 useCallback 훅은 콜백 함수의 참조를 메모이제이션2하고 최적화할 때 사용합니다. 특히 콜백 함수를 자식 컴포넌트에 전달하거나, 콜백을 다른 훅의 의존성 목록으로 지정할때 유용합니다.

```tsx
const memoizedCallback = useCallback(callback, dependencies)
```

- callback: 메모이제이션 대상이 되는 함수. 인라인 함수 또는 함수 참조(변수)가올 수 있습니다.
- dependencies: 메모이제이션하려는 콜백 함수의 의존성 배열. 의존성 배열에 명시된 값이 변화하면, 콜백을 다시 생성합니다.

#### [예제]

본문의 요약 내용을 수정하는 에디터 컴포넌트가 필요합니다. 사용자가 글자를 입력할 때마다 본문에 업데이트가 필요하며, 이는 리렌더링을 발생시킵니다. 그러나 리렌더링할 때마다 새로운 함수가 생성되며 이는 성능에 영향을 미치게 됩니다. useCallback 훅을 통해 불필요한 함수 재생성을 방지하여 렌더링 과정을 최적화합니다.

```tsx
const ArticleEditor = ({ id }: { id: string }) => {
  const submitChange = useCallback(
    async (summary: string) => {
      try {
        // Make a POST request to update the article item
        await fetch(`/api/articles/${id}`, {
          method: 'POST',
          body: JSON.stringify({ id, summary }),
          headers: {
            'Content-Type': 'application/json',
          },
        })
      } catch (error) {
        // handling errors
      }
    },
    [id]
  )

  return (
    <div>
      <ArticleForm onSubmit={submitChange} />
    </div>
  )
}
```

ArticleEditor 컴포넌트에서 useCallback은 비동기 POST 요청을 통해 본문을 업데이트하는 submitChange 함수를 메모이제이션하고 있습니다. useCallback을 사용하여 submitChange가 id prop이 바뀔 때만 다시 생성되도록 하여 불필요한 재계산을 줄여 성능을 최적화했습니다.

```tsx
const ArticleForm = ({ onSubmit }: { onSubmit: (summary: string) => void }) => {
  const [summary, setSummary] = useState<string>('')

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault()
    onSubmit(summary)
  }

  const handleSummaryChange = useCallback(
    (event: ChangeEvent<HTMLTextAreaElement>) => {
      setSummary(event.target.value)
    },
    []
  )

  return (
    <form onSubmit={handleSubmit}>
      <h2>Edit Article</h2>
      <textarea value={summary} onChange={handleSummaryChange} />
      <button type='submit'>Save</button>
    </form>
  )
}
```

ArticleForm은 useState 훅을 사용하여 본문 요약 상태(summary)를 관리합니다. 폼을 제출할 때 handleSubmit은 브라우저의 폼 제출 기본 동작방식을 중단하고 현재의 본문 상태를 onSubmit 함수의 인자로 전달하여 호출합니다. useCallback 함수로 최적화된 handleSummaryChange 함수는 textarea에 입력된 본문 요약 상태를 업데이트합니다. useCallback을 이용하면 함수는 렌더링이 발생하더라도 매번 다시 생성되지 않으므로 성능이 개선됩니다.

### 리액트 Context API

리액트 Context API는 데이터를 계층마다 일일이 prop을 통해 수동으로 전달하지 않고 컴포넌트 하위 트리에 직접 전달할 수 있도록 해주는 기능입니다. 애플리케이션에 많은 자식 컴포넌트들과 공유해야 하는 전역 데이터가 있거나, 중간 컴포넌트들이 데이터가 필요하지 않고 하위 컴포넌트에 전달만 하는 경우에 유용합니다.

리액트에서 Context API는 애플리케이션의 컴포넌트에서 접근 가능한 전역 상태를 만들고 관리합니다. 이 특성은 각기 다른 관점의 상태를 관리하는 여러 Context Provider를 조합하여 애플리케이션에 제공할 수 있습니다.

<u>보안, 로깅 또는 그 외의 관심사로 각각 컨텍스트 프로바이더를 분리하여 사용하면, 관련된 데이터와 기능을 효율적으로 구성할 수 있습니다.</u> 각각의 컨텍스트 프로바이더는 관심사별로 캡슐화하여 애플리케이션의 다른 부분에 영향을 주지 않고 상태를 업데이트하거나 관리할 수 있습니다.

#### [예제]

현재 시간을 기준으로 사용자에게 다크 또는 라이트 테마를 보여주는 애플리케이션을 만든다고 합시다. 최상위 루트 레벨에서 테마값의 설정이 필요합니다.

```tsx
type Theme = {
  theme: 'light' | 'dark'
  toggleTheme: () => void
}

const ThemeContext = React.createContext<Theme>({
  theme: 'light',
  toggleTheme: () => {},
})

const ThemeProvider = ({ children }: { children: ReactNode }) => {
  const [theme, setTheme] = useState<'light' | 'dark'>('light') // default theme is light

  const toggleTheme = useCallback(() => {
    setTheme((prevTheme) => (prevTheme === 'light' ? 'dark' : 'light'))
  }, [])

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}
```

```tsx
const Root = () => {
  return (
    <ThemeProvider>
      <App />
    </ThemeProvider>
  )
}

const Article = ({ heading, summary }: ArticleType) => {
  const { theme, toggleTheme } = useContext(ThemeContext);

  return (
    <article className={theme}>
      <h3>{heading}</h3>
      <p>{summary}</p>
      <button onClick={toggleTheme}>Toggle</button>
    </article>
  ）;
};
```

[Toggle] 버튼을 누를 때마다 테마가 변경되고 리렌더링이 발생합니다.
