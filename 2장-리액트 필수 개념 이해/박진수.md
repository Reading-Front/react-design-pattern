# 2장 리액트 필수 개념 이해

## 리액트 정적 컴포넌트

- 단순하게 prop을 전달받아 그에 맞게 UI를 렌더링하는 컴포넌트.

## prop이 있는 컴포넌트 만들기

- prop만 다르게 들어오는 공통화된 컴포넌트 사용이 가능하다.
- 관리하기 쉬운 컴포넌트를 만들고자 한다면 prop 속성은 가능하면 5,6개를 넘지 않는 것이 좋다.

## UI를 여러 컴포넌트로 나누기

- prop값에 따른 동적 클래스명을 사용하시는지 궁금.
- 현재 회사에서는 단순히 styled 컴포넌트를 사용하고 prop으로 styled 코드 내에서 분기처리를 진행.

## 렌더링 과정 이해하기

- useEffect 문 안에서 타이머를 설정했다면 메모리 누수가 되지 않도록 clean up 로직을 잘 작성해줘야 한다.
- 그렇지 않다면 메모리 누수가 일어날 수 있다.
- 밑에 코드의 abort 컨트롤 로직은 나중에 적용을 해봐야겠다. 현재 회사에서는 한번 api 요청 보낸 걸 abort하는 로직이 없어서.

```ts
useEffect(() => {
  const controller = new AbortController();
  const signal = controller.signal;
  const fetchArticle = .....

  fetchArticle(id);

  return () => {
    controller.abort();
  }
}'
},[id]);
```

## useCallback

```tsx
const ArticleForm = ({ onSubmit } : {onSubmit: (summary:string)=>void}) => {
  const [summary, setSummary] = useState<string>('');

  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    onSubmit(summary);
  }

  const handleSummaryChange = useCallback(
    (event: ChangeEvent<HTMLTextAreaElement>) => {
      setSummary(event.target.value);
    },
    [].
  }

  return (
    <form onSubmit={handleSubmit}>
      <h2>Edit Article</h2>
      <textarea value = {summary} onChange = {handleSummaryChange} />
      <button type="submit">Save</button>
    </form>
  );
}
}
```

- 여기서 굳이 handleSummaryChange 함수에 useCallback 훅을 걸었어야 했나 싶다.
- 어차피 textarea에서 onChange가 일어날 때 마다 ArticleForm이 리렌더링이 될거고 handleSummaryChange 함수도 재생성된다고 되지만, 이게 성능상 이슈가 있을까?
- 연산이 적게 걸림에도 불구하고 useCallback 함수 사용은 코드 파악이 어려워진다고 생각함.
