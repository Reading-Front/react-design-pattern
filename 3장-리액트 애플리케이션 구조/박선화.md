# 3장 리액트 애플리케이션 구조

잘 갖춰진 구조는 유지보수하기 쉽고, 새로운 팀원이 합류했을 때 이해하기 쉽고 기능을 확장하기 쉬운 덕분에 프로젝트 성공에 전반적인 영향을 끼치게 됩니다. 반면에 비효율적인 구조는 코드 스멜을 유발시키고 코드 복잡도를 높이며 기술 부채의 온상이 되기 쉽습니다.

## 1. 구조화되지 않은 프로젝트의 문제점

구조화가 덜 된 프로젝트의 문제점은 효과적으로 관리하고 유지보수가 어렵다는 것입니다.

- 무질서한 코드 : 명확한 구조가 없으면, 특정 코드 파일이나 컴포넌트를 찾는 것이 어려워집니다.
- 낮은 코드 재사용성 : 적절한 구조가 없다면, 재사용할 수 있는 컴포넌트나 기능을 식별하는 것이 쉽지 않습니다. 이는 코드 중복과 일관성 부족으로 이어질 수 있으며, 장기적으로 코드베이스를 유지하고 업데이트하기가 어려워집니다.
- 협업의 어려움 : 팀원들이 서로의 코드를 이해하고 탐색하는 것이 어려워집니다. 이로 인해 의사소통, 느린 개발 속도、그리고 버그나 코드 변경 충돌을 일으킬 위험이 있습니다.
- 확장성 문제 : 기존 코드에 다른 구성 요소를 통합하는 것이 어려워집니다. 확장과 수정이 어려운 꼬인 코드베이스가 되기 쉽고 생산성 감소와 개발 시간 증가로 이어집니다.
- 복잡한 유지보수 문제 : 코드를 구성하거나 이름 짓는 방식에 일관성이 부족하므로 기능을 변경하거나 문제를 해결할 때 더 많은 시간이 소요됩니다.

## 2. 프론트엔드 애플리케이션의 복잡함에 대한 이해

리액트 프로젝트의 폴더 구조는 일반적인 리액트 코드베이스에서 관리해야 할 다양한 측면을 보여줍니다.

- **소스 코드**: 애플리케이션의 핵심이며, 애플리케이션의 로직을 담고 있는 자바스크립트 또는 타입스크립트 파일, UI 구조를 위한 HTML 파일, 디자인을 표현하는 스타일 파일이 있습니다. 애플리케이션의 동작과 사용자 인터페이스를 정의하는 모든 것은 여기에서 찾을 수 있습니다.
- **에셋**: 이 카테고리에는 애플리케이션에서 활용하는 이미지, 비디오, 폰트와 같은 모든 정적 파일이 있습니다.
- **설정**: 이 파일들은 애플리케이션의 다양한 부분을 제어하는 중요한 매개변수를 포함합니다. 의존성 목록을 관리하는 package, json과 프로젝트를 빌드할 때 필요한 환경변수는 애플리케이션을 운영하고 배포하는 데 중요합니다.
- **테스트**: 이 영역은 애플리케이션의 올바른 동작과 안정성을 위해 필요합니다. 사용자 동작을 재현하고 상호작용을 검증하며 애플리케이션의 기능을 확인하는 유닛, 통합, E2E 테스트를 담고 있습니다. 이는 잠재적인 버그를 예방하는 데 도움이 됩니다.
- **문서** : 프로젝트 개요를 제공하는 README 파일, API 문서와 코드 스타일 가이드 등 애플리케이션에 필요한 모든 정보가 문서에 있습니다. 프로젝트와 연관된 사람들은 문서를 통해 프로젝트를 쉽게 이해하고 코드의 일관성을 유지할 수 있습니다.
- **빌드 결과물**: 배포 가능한 최적화된 번들 자바스크립트, CSS, HTML 그리고 디버깅에 도움이 되는 진단 파일과 임시 파일들을 포함한 빌드 실행 결과물입니다. 애플리케이션을 최종 사용자에게 전달하는 핵심 요소입니다.
- **개발 도구와 설정 파일**: 코드의 품질과 일정한 포맷을 유지하고 형상을 관리하여. 자동화된 테스팅과 배포 절차를 쉽게 해주는 도구입니다. 백그라운드로 작업이 수행되며, 원활하고 오류가 없는 효율적인 개발 과정을 만들어줍니다.

다양한 파일이 많은 상황에서 쉽게 탐색하고 빠르게 수정하기 위해서는 파일을 어떻게 정리해야 할까요?

단 하나의 방법으로 모든 요구사항을 만족할 수는 없지만, 코드베이스를 일관되게 정리하는 것이 큰 도움이 됩니다.
코드 요소의 이름을 짓고 구조화할 때는 일관성을 유지하는 것이 가장 중요합니다. 어떤 방식을 선택하든, 프로젝트 전반에 걸쳐 일관된 방식을 유지해야 합니다. 예를 들어 스타일 파일을 컴포넌트와 함께 배치하기로 정했다면, 이를 코드베이스의 모든 컴포넌트에 적용해야 합니다.

## 3. 일반적인 리액트 애플리케이션 구조

자주 사용되는 4가지 구조를 알아보겠습니다.

- 기능 기반 구조
- 컴포넌트 기반 구조
- 아토믹 디자인 구조
- MVVM 구조

구조마다 각각의 장단점이 있으므로, 프로젝트마다 필요한 기능이나 복잡도를 파악하여 어떤 구조를 사용할지 결정해야 합니다. 프로젝트에 필요한 특별한 기능이 있다면. 여러 개의 구조를 적절히 섞는 방법도 있습니다.

### 기능 기반 구조

애플리케이션을 기능과 모듈 중심으로 구조화하는 것을 의미합니다. 기능 단위로 명확하게 분리하기 위해 컴포넌트와 뷰, API 호출, 상태 관리를 캡슐화하여 관리합니다.

- features 디렉터리 - Home, Cart, ProductDetails, Checkout, Profile 등과 같은 애플리케이션의 기능을 의미합니다.
  - 기능마다 components, containers, pages, services, types와 utils 폴더를 가집니다.
- shared 디렉터리 - 여러 기능에서 공유하여 재사용하는 components, containers, services, types, utils를 가집니다.
- api 디렉터리 - API 호출을 하는 모듈을 가집니다.
- store 디렉터리 - 리덕스와 같은 상태 관리를 위한 모듈을 가집니다.
- router 디렉터리 - 라우팅 설정과 관련된 컴포넌트를 가집니다.
- App.tsx 파일 - 애플리케이션의 시작점입니다.

#### 장점

- 명확한 관심사 분리 : 각 기능과 관련된 코드를 쉽게 찾고 수정할 수 있습니다.
- 모듈화 : 기능 단위로 코드가 모여 있으므로 코드 테스팅과 유지보수, 재사용이 쉽습니다.
- 확장성 : 새로운 기능이 추가될 때 기존 코드에 영향을 주지 않습니다.
- 팀 협업 : 여러 기능을 개발자들이 동시에 작업할 때 코드 충돌을 최소화할 수 있습니다.

#### 단점

- 코드 중복의 가능성 : 기능들이 비슷한 컴포넌트나 로직을 갖고 있으면 코드 중복이 발생할 수 있습니다. 신중하게 설계하거나 리팩터링을 통해 이를 피해야 합니다.

### 컴포넌트 기반 구조

애플리케이션을 재사용할 수 있는 컴포넌트 단위로 구조화하는 것입니다. 컴포넌트는 기능 단위로 분류하고 이를 조합하여 더 큰 뷰를 만듭니다.

- components 폴더 - 애플리케이션의 여러 기능에서 사용하는 개별 컴포넌트를 가지게 됩니다.
  - 각각의 컴포넌트는 폴더에 존재하며, 필요할 경우 자식 컴포넌트를 가집니다.
  - 예) ProductList, ShoppingCart, UserAuth, Payment
  - 예) UserAuth - Login, SignUp
- routes 폴더 - 애플리케이션의 프런트엔드 라우팅을 담당합니다.
  - 라우팅 로직을 설정하는 메인 AppRouter.tsx 파일
  - 개별 라우팅 경로와 그에 해당하는 컴포넌트를 담은 routes.tsx 파일

#### 장점

- 모듈화 : 컴포넌트 기반 구조는 기능 단위의 컴포넌트를 별도의 파일과 폴더에 구분하여 모듈화합니다. 이로 인해 코드를 유지보수하기 쉽고 재사용성이 높아집니다.
- 관심사 분리 : 컴포넌트의 개별 기능에 집중하게 되어 코드가 간결해지고 디버깅하기 쉽습니다. 관심사를 분리하면 유지보수하기 쉽고 코드 가독성이 높아집니다.
- 높은 코드 재사용성 : 애플리케이션의 여러 곳에서 컴포넌트를 재사용하고, 이후 또 다른 프로젝트에서도 활용하여 개발 생산성을 높일 수 있습니다.

#### 단점

- 프로젝트 복잡도 증가 : 프로젝트가 커질수록 컴포넌트 폴더 구조가 복잡해지고 단순하게 유지하기 어렵습니다. 관리 가능한 수준을 유지하기 위해서는 모범사례를 참고하여 신중하게 설계하고 계획을 세워야 합니다.
- 높은 진입장벽 : 컴포넌트 기반의 개발과 타입스크립트에 익숙하지 않다면 초기 학습 곡선이 가파르게 올라갑니다. 하지만 초기 학습에 드는 비용보다 구조화된 코드가 가져다 주는 장점이 더 많습니다.
- 코드 중복의 가능성 : components 폴더 안에서는 다른 컴포넌트와 동일하거나 기능이 유사한 컴포넌트를 찾기 쉽습니다. 컴포넌트를 더 잘게 나눌수록. 재사용할 수 있는 컴포넌트를 찾기 쉬워질 것입니다. 재사용할 수 있는 컴포넌트가 점점 늘어난다면. 기능 기반 구조에서 보았던 대로 공유 폴더로 옮겨보는 것에 대해 고려해 볼 수 있습니다.

### 아토믹 디자인 구조

사용자 인터페이스를 체계화하는 디자인 방법론입니다. 사용자 인터페이스를 원자라고 부르는 재사용 가능한 작은 단위로 나누고 이를 합성하여 분자(molecules), 유기체(organisms), 템플릿templates), 페이지(pages) 등의 큰 단위를 만들어냅니다.

아토믹 디자인의 핵심 아이디어는 UI 컴포넌트를 만드는 체계적인 접근 방식을 설계하여 재사용성과 확장성, 유지보수성을 높이는 것입니다. 컴포넌트를 구성하고 이름을 지정하기 위한 명확한 구조를 제시함으로써 UI 코드베이스를 쉽게 이해하고 탐색할 수 있습니다.

#### 아토믹 디자인 방법론에서 UI 컴포넌트 분류

- 원자 : **UI를 구성하는 가장 작은 요소**이며 버튼, 인풋, 아이콘 또는 레이블 등의 기본 요소들이 있습니다.
- 분자 : 원자들을 조합하여 복잡한 UI 컴포넌트를 표현합니다. 여러 원자가 상호작용을 하여 기능 단위를 구성합니다. 폼 입력, 내비게이션 바 등이 있습니다.
- 유기체 : 더 커다란 컴포넌트이며 분자 또는 원자들을 결합하여 기능 영역의 UI를 표현합니다. 헤더, 사이드바, 카드, 컴포넌트 등 **사용자 인터페이스의 기능 영역**을 표현합니다.
- 템플릿 : 분자 또는 유기체들을 배치하는 레이아웃 구조입니다. 페이지의 전반적인 구조와 UI의 기능 영역을 표시합니다.
- 페이지 : 템플릿과 유기체, 분자, 원자 등을 모두 결합한 온전한 사용자 화면 구성 전체를 의미합니다. 사용자에게 전달되는 최종 결과물입니다.

아토믹 디자인 구조를 자세히 살펴봅니다.

- components 폴더 : atoms, molecules, organisms, templates, pages 디렉터리는 컴포넌트 합성과 추상화의 다양한 레벨을 나타냅니다.
  - atoms : Button, Input, Icon ...
  - molecules : ProductCard, ShoppingCart, ProductFilter, ...
  - organisms : Header, Footer, CheckoutForm, ...
  - templates : HomePage, ProductDetailPage, CheckoutPage, ...
  - pages: Home, ProductDetail, Checkout, ...
- api 폴더 : API 호출과 관련된 파일을 담고 있다.
- views 폴더 : 컴포넌트를 렌더링하는 개별 단위의 view 파일을 담고 있다.
  - views - HomeView.tsx, ProductDetailView.tsx, ...
- routes 폴더 : 라우팅 설정
  - routes - index.tsx, routes.tsx

#### 장점

- 재사용성 : 컴포넌트를 애플리케이션 전체에서 쉽게 재사용할 수 있어 코드 효율성이 높습니다.
- 일관성: UI 패턴과 디자인에 대한 일관된 적용이 가능합니다.
- 확장성: 모듈화된 접근 방법을 통해 컴포넌트 기능 확장이 쉽고 신규 컴포넌트를 추가하기 용이합니다
- 유지보수성 : 컴포넌트가 논리적으로 구조화되어 있어 찾거나 업데이트하기 쉽습니다.
- 쉬운 협업: 아토믹 디자인 구조는 디자이너와 개발자가 UI 컴포넌트에 관해 논의할 때 공통 언어의 역할을 하므로 협업하기 쉽습니다.

#### 단점

- 높은 진입장벽 : 아토믹 디자인 원칙을 효과적으로 구현하려면 초반에 학습과 적응 과정이 필요합니다.
- 복잡도 : 애플리케이션이 커질수록 컴포넌트 개수가 늘어나고 그 관계가 복잡해져서 관리가 어렵습니다.
- 오버 엔지니어링 : 과도한 추상화는 필요 이상으로 구조를 복잡하게 만들기 때문에 컴포넌트 재사용성과 오버 엔지니어링 사이의 균형을 맞추는 것이 중요합니다.

### MVVM 구조

MVVM(Model-View-ViewModel) 구조는 주로 사용자 인터페이스를 만드는 데 사용되는 아키텍처 패턴입니다.

- 모델 : 실제 다루는 데이터 또는 정보를 의미합니다. 데이터베이스, 파일, 웹서비스 또는 단순한 객체일수도 있습니다.
- 뷰 : 사용자가 보면서 상호작용하는 것을 말합니다. 모델을 사용자에게 보여주는 역할을 하는 것이 사용자 인터페이스입니다.
- 뷰모델 : 대부분의 로직이 위치하는 곳입니다. 외부에 공개되는 속성과 명령이 있는 추상화된 뷰입니다.
  뷰와 모델 사이의 차이를 메워주며, 모델의 데이터를 뷰가 쉽게 처리할 수 있는 형식으로 가공해줍니다.
  데이터에 대한 작업을 수행하고 뷰에 어떻게 보여줄지를 결정합니다.

MVVM 구조 자세히 살펴보기

- views 폴더 - ViewModel의 상태에 따라 화면에 보여주는 UI 컴포넌트가 있습니다.
  - CartView.tsx, ProductListView.tsx
  - components
    - Product - ProductCard.tsx, ProductList.tsx
    - Shared - Button.tsx, Input.tsx
- models 폴더 - CartItemModel.ts, ProductModel.ts
- viewModels 폴더 - useCartViewModel.ts, useProductListViewModel.ts
- services 폴더 - API 호출과 외부 서비스와의 연결을 위한 파일이 있습니다.
- routers 폴더 - 라우팅 설정과 관련된 컴포넌트가 있습니다.
- App.tsx 파일 - 애플리케이션의 진입접입니다.

#### 장점

- 관심사 분리 : 뷰모델은 UI 컴포넌트에서 비즈니스 로직을 분리하여, 유지보수하기 쉽고 깔끔한 코드를 작성할 수 있습니다.
- 쉬운 테스팅 : 뷰모델은 실제 UI 컴포넌트 없이도 쉽게 단위 테스트가 가능합니다.
- 높은 재사용성 : 컴포넌트와 모델. 서비스는 다른 기능이나 뷰에서도 쉽게 재사용할 수 있습니다.
- 높은 확장성: 기존에 사용하던 뷰모델에 새로운 기능이나 뷰를 쉽게 추가할 수 있습니다.

#### 단점

- 복잡도 증가: MVVM 패턴을 도입하면 추상화 계충을 추가하게 되며, 특히 프로젝트 규모가 작다면 이로 인한 애플리케이션 복잡도가 증가합니다.
- 높은 진입장벽: MVVM 개념과 사용법에 대한 이해가 필요합니다.

## 4. 프로젝트 구조를 체계적으로 유지하기

기능 기반의 구조는 프로젝트 초기에 유용한 전략입니다. 프로젝트가 커지고 비슷한 패턴들이 반복되기 시작한다면, 추가 계층을 만들어 중복을 피할 수 있습니다.

### 중복 제거를 위한 계층 추가

계층을 추가하면, 코드베이스의 재사용성과 유지보수성을 높일 수 있습니다. 중복을 제거하고 개발 효율을 높이며 애플리케이션 전반에 걸쳐 일관성이 확보됩니다. 프로젝트가 더 커지더라도 이런 모듈화된 접근 방식 덕분에 관리와 확장이 쉽고, 전체 코드베이스에 영향을 주지 않으면서 신규 기능을 추가하거나 변경할 수 있습니다.

- components 폴더에 재사용 가능한 모든 컴포넌트를 넣습니다.
- pages 폴더에 페이지와 관련된 모든 컴포넌트를 넣습니다.
- hooks 폴더는 재사용하는 로직과 기능을 제공하는 리액트 훅을 담고 있습니다.
- context 폴더는 전역 상태 관리에 쓰이며, 애플리케이션에서 공유되는 다양한 컨텍스트를 담고 있습니다.

프로젝트가 커질수록, 여러 페이지에서 공유하며 사용할 수 있는 컴포넌트들을 수용할 별도의 분리된 폴더가 필요합니다. 이 구조에서 컴포넌트는 각 기능의 이름을 가진 폴더 내에 구성되어 있기 때문에 모듈성과 코드 재사용성이 높아집니다. 또한 컴포넌트를 계층화하여 표현할 수도 있습니다.

이 파일 구조는 프로젝트 구조가 커지더라도 더 나은 조직화, 코드 재사용, 쉬운 코드 확장을 가능하게 합니다. 따라서 중복을 줄이고 애플리케이션 내의 일관성을 유지할 수 있기 때문에 관리하기 쉽습니다. 또한 훅과 컨텍스트를 별도 폴더로 분리하기 때문에. 관련된 코드를 한곳에 모으고 전역 상태와 재사용하는 로직을 관리하기 용이합니다.

### 파일 이름 짓기

#### index.tsx를 사용하여 명시적인 컴포넌트 이름과 파일 이름 짓기

컴포넌트 이름으로 폴더를 생성하고 각 파일은 컴포넌트를 구성하는 요소의 명시적인 이름으로 표현합니다.

- components/Button
  - Button.test.tsx
  - Button.tsx
  - index.tsx
  - style.css

index.tsx 파일은 외부에서 컴포넌트를 바로 import하여 사용할 수 있게 노출하는 기본 export 파일입니다.
Button.tsx는 JSX 컴포넌트이며, 테스트 파일, 스타일 파일을 정의합니다.

이 접근 방식은 파일명이 기능을 설명하여 쉽게 이해할 수 있고, 각 파일의 목적이 분명하게 드러납니다. 그러나 파일 탐색기나 개발 도구에서 파일을 찾을 때 긴 인덱스가 생성될 수 있습니다.

#### 케밥 케이스로 파일 이름 짓기

이 방식은 components 폴더 하위에 케밥 케이스 규칙으로 이름을 정합니다.

> 케밥 케이스 : 단어를 소문자로 쓰고 하이픈으로 나누는 방식

- components
  - button.test.tsx
  - button.tsx
  - index.tsx
  - style.css

이 방식은 프로젝트 전반에 걸쳐 케밥 케이스로 통일된 일관성 있는 이름 구조를 만들 수 있습니다. 그러나 컴포넌트를 임포트할 때는 명시적인 이름을 적어야 합니다.

어떤 방식을 선택할지는 개인의 선호도나 프로젝트의 요구사항, 팀의 관례를 고려하여 정합니다. 프로젝트에서 일관성을 유지하는 것은 프로젝트 팀원들이 이해와 협업을 쉽게 할 수 있기 때문에 매우 중요합니다.

어떤 방식이든 ESLint와 FolderLint 도구를 사용하면 팀 안에서 파일과 폴더에 대해 동일한 기준으로 이름 짓기가 적용되는지 확인할 수 있습니다.

### 사용자 설정 구조 살펴보기

애플리케이션이 커지고 서로 다른 타입의 추상화 계층이 추가되면, 그에 걸맞는 프로젝트 구조화가 필요합니다.
지금까지 알아본 구조들이 여러분의 특정한 상황에 딱 맞지 않을 수 있습니다. 프로젝트 요구사항에 맞춰 앞서 소개했던 구조들을 변형하는 것이 종종 필요합니다.
프로젝트 구조를 세우는 근본적인 목적은 개발 과정을 단순화하고 간소화하는 것입니다.

기능 기반의 구조에서 시작했을 때, 이러한 변화를 반영하기 위해선 다음과 같이 변경해야 합니다.

- api: 네트워크 요청을 발생시키고 응답을 다루며, 백엔드 서비스와 상호작용하는 API 관련 코드를 관리하는 모듈 또는 디렉터리입니다.
- components： 애플리케이션에서 여러 페이지와 기능을 넘나들며 재사용 가능한UI 컴포넌트가 있는 폴더입니다.
  - Accordion, Button, GenericCard, Modal. Offer. Stackview와 같은 컴포넌트가 있습니다. 이 컴포넌트들은 기능이나 목적에 따라 서브 폴더로 다시 나뉘기도 합니다.
- context: 전역 상태를 관리하고 컴포넌트 간에 데이터를 공유하게 해주는 리액트 컨텍스트 모듈이 위치한 폴더입니다.
- hooks: 재사용 가능한 로직과 행위를 담고 있는 사용자 정의 리액트 훅이 있습니다. 이 훅은 애플리케이션의 전반에 걸쳐 공유될 수 있습니다.
- mocks： 테스팅 목적의 모킹 데이터 또는 모킹 구현체를 가지고 있습니다. 그래프QL 데이터를 모킹하는 graphql 폴더와 REST API를 모킹하는 rest 서브 폴더가 있습니다.
- pages: 이 폴더는 애플리케이션의 다양한 페이지나 기능이 있습니다. 페이지 또는 기능 단위로 폴더가 있습니다.
  - Address, Home. Login. Order. Payment. Product, Profile, SignUp이 있으며, 하위에 서브 폴더가 있습니다.
  - 서브 폴더는 페이지 또는 기능에 추가로 필요한 부가적인 컴포넌트와 훅, 컨텍스트를 담고 있습니다.

프로젝트의 구조를 세우면, 모듈화 되고 구조화된 코드베이스를 만들 수 있습니다. 이를 통해 코드 재사용성을 높이고, 관심사를 분리하고, 확장하기 쉬워집니다. 각각의 디렉터리는 애플리케이션의 특정 부분을 나타내며 코드를 더 쉽게 찾고 관리할 수 있습니다.

구조는 프로젝트의 구체적인 요구사항 또는 확장에 따라 변경하는 것이 중요합니다. 구조를 정기적으로 리뷰하고 리팩터링하여, 효율성을 유지하고 미래의 변경 가능성에 효과적으로 대비할 수 있습니다.

애플리케이션이 커지면, components 폴더를 공용 라이브러리로 분리하여 여러 프로젝트에서 함께 사용하거나 내부 디자인시스템으로 활용하는 것이 유리할 수 있습니다. 이 전략은 코드 재사용과 일관성, 유지보수성을 높여줍니다. 이 공용 라이브러리는 내부 레지스트리 또는 npm 레지스트리에 등록하여 배포하고 사용할 수 있습니다.

접근 방식의 장단점과 고려해야 할 사항들을 파악하여, 프로젝트의 요구사항에 가장 적합한 구조를 선택합니다. 또한 프로젝트의 성장에 맞추어 폴더 구조를 함께 진화시키는 접근 방식을 가져야 합니다. 간단한 초기 구조에서 시작하여, 중복을 줄이고 = 체계를 유지하기 위해 새로운 계층을 도입하고 추상화를 적용해야 합니다. 계속해서 구조를 다듬고 일관된 규칙을 준수함으로써, 효과적으로 기능을 추가하고 유지보수 및 확장할 수 있습니다.
