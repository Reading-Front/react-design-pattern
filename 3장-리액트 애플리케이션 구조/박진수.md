# 3장 리액트 애플리케이션 구조

## 구조화되지 않은 프로젝트의 문제점

- 구조화가 덜 된 프로젝트의 문제점은 코드베이스를 효과적으로 관리하고 유지보수가 어렵다는 것이다.

### 무질서한 코드

- 명확한 구조가 없으면, 특정 코드 파일이나 컴포넌트를 찾는 것이 어려워진다. 특히 프로젝트가 커질수록 관련 코드를 찾는 시간과 노력을 낭비할 수 있다.

### 낮은 코드 재사용성

- 적절한 구조가 없다면, 재사용할 수 있는 컴포넌트나 기능을 식별하는 것이 쉽지 않습니다. 이는 코드 중복과 일관성 부족으로 이어질 수 있으며, 장기적으로 코드베이스를 유지하고 업데이트하기가 어려워진다.

### 협업의 어려움

- 구조화가 덜 된 프로젝트를 진행하다 보면 팀원들이 서로의 코드를 이해하고 탐색하는 것이 더 어려워진다.
- 이로 인해 의사소통, 느린 개발 속도, 그리고 버그나 코드 변경 충돌을 일으킬 위험이 있다.

### 확장성 문제

- 프로젝트가 커지고 새로운 기능이 늘어날수록 또 다른 구성 요소를 원할하게 기존 코드에 통합하는 것이 어려워진다.
- 확장과 수정이 어려운 꼬인 코드베이스가 되기 쉽고 생산성 감소와 개발 시간 증가로 이어진다.

### 복잡한 유지보수 문제

- 명확한 구조가 없다면 유지보수하기 어려워진다. 코드를 구성하거나 이름 짓는 방식이 일관성이 부족하므로 기능을 변경하거나 문제를 해결할 때 더 많은 시간이 소모된다.

## 프론트엔드 애플리케이션의 복잡함에 대한 이해

### 에셋

- 이미지, 비디오, 폰트와 같은 모든 정적 파일이 있다.

### 설정

- package.json, 환경 변수가 존재한다.

### 테스트

- 유닛, 통합, E2E 테스트를 담고 있다.

### 문서

- README 파일

### 빌드 결과물

- dist 폴더

### 개발 도구와 설정 파일

- 자동 CICD 배포 도구

## 일반적인 리액트 애플리케이션 구조

### 기능 기반 구조

- 기능 기반 구조란 애플리케이션을 기능과 모듈 중심으로 구조화하는 것을 의미한다.
- 기능 단위로 명확하게 분리하기 위해 컴포넌트와 뷰, API 호출, 상태 관리를 캡슐화하여 관리한다.

```md
src/
├── features/
│ ├── login/
│ │ ├── LoginPage.tsx
│ │ ├── loginSlice.ts // 상태 관리
│ │ ├── loginApi.ts // API 호출
│ │ ├── types.ts
│ │ └── index.ts
│ ├── cart/
│ │ ├── CartPage.tsx
│ │ ├── cartSlice.ts
│ │ ├── cartApi.ts
│ │ └── ...
```

#### 장점

- 한 기능에 필요한 파일이 한 폴더에 모여 있어서 찾기 쉽고 변경 범위가 좁음.
- 기능 추가 / 수정 시 다른 기능에 영향 없이 작업 가능

#### 단점

- 코드 중복의 가능성이 있다.

### 컴포넌트 기반 구조

- 애플리케이션을 재사용할 수 있는 컴포넌트 단위로 구조화하는 것이다.
- 컴포넌트는 기능 단위로 분류하고 이를 조합하여 더 큰 뷰를 만든다.

```md
src/
├── components/
│ ├── Header/
│ │ ├── Header.tsx
│ │ ├── Header.styles.ts
│ │ └── index.ts
│ ├── Button/
│ │ ├── Button.tsx
│ │ ├── Button.types.ts
│ │ ├── Button.test.tsx
│ │ └── Button.styles.ts
├── pages/
│ ├── HomePage.tsx
│ └── LoginPage.tsx
```

#### 장점

- 모듈화: 기능 단위의 컴포넌트를 별도의 파일과 폴더에 구분하여 모듈화 한다.
- 관심사 분리: 컴포넌트의 개별 기능에 집중하게 되어 코드가 간결해지고 디버깅하기 쉽다.
- 높은 코드 재사용성: 애플리케이션의 여러 곳에서 컴포넌트를 재사용한다.

### 아토믹 디자인 구조

- 아토믹 디자인은 사용자 인터페이스를 체계화하는 디자인 방법론이다.
- 개인적으로 실무에서 사용할까 의문이 든다.
  <<<<<<< HEAD
  =======
- 기능 단위로 명확하게 분리하기 위해 컴포넌트와 뷰, API 호출, 상태 관리 캡슐화하여 관리한다.

### 컴포넌트 기반 구조

- 애플리케이션을 재사용할 수 있는 컴포넌트 단위로 구조화하는 것이다.
- 컴포넌트는 기능 단위로 분류하고 이를 조합하여 더 큰 뷰를 만든다.

### 아토믹 디자인 구조

- 아토믹 디자인은 사용자 인터페이스를 체계화하는 디자인 방법론이다.
  > > > > > > > f0f4e58b11d17e29d81ef09c78c4831fa6b1fd3d

### MVVM 구조 (Model-View-ViewModel)

- 주로 사용자 인터페이스를 만드는 데 사용되는 아키텍처 패턴이다.
- MVVM은 UI 구조를 3가지 관심사로 나누는 아키텍처 패턴.

```md
Model ←→ ViewModel ←→ View
(데이터) (로직, 상태) (화면)
```

- Model
  - 데이터 계층, API 응답, DB 모델
- View
  - 실제 사용자에게 보이는 UI
- ViewModel
  - 비즈니스 로직 + 상태 관리 -> View에 바인딩

예시.

#### Model

- API 응답 데이터, DB 스키마, 도메인 객체 등
- 외부 세계와 연결된 순수 데이터 구조

```ts
// models/User.ts
export interface User {
  id: string;
  name: string;
}
```

#### ViewModel

- Model 데이터를 가공하여 View에 전달
- 상태(state)와 행동(method)을 관리
- View는 ViewModel을 구독하고 상태 변화에 반응

```ts
// viewmodels/useUserViewModel.ts
import { useState, useEffect } from "react";
import { fetchUser } from "@/apis/userApi";

export const useUserViewModel = (userId: string) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  const loadUser = async () => {
    setLoading(true);
    const data = await fetchUser(userId);
    setUser(data);
    setLoading(false);
  };

  useEffect(() => {
    loadUser();
  }, [userId]);

  return { user, loading };
};
```

#### View

- 화면을 그리는 역할만 담당
- ViewModel에서 받아온 상태와 메서드를 사용

```ts
// views/UserProfile.tsx
import { useUserViewModel } from "@/viewmodels/useUserViewModel";

export const UserProfile = ({ userId }: { userId: string }) => {
  const { user, loading } = useUserViewModel(userId);

  if (loading) return <p>Loading...</p>;
  if (!user) return <p>No user found</p>;

  return <div>{user.name}</div>;
};
```

#### 실무 팁 (React 기준)

- ViewModel은 커스텀 훅으로 구현

## 현재 다니는 회사는 어떤 구조?

```md
src/
├── pages/
│ ├── login.tsx ← 라우팅되는 페이지 컴포넌트
│ ├── dashboard.tsx
│ └── ...
├── components/
│ ├── Login/ ← Login 페이지에서만 쓰는 컴포넌트들
│ │ ├── LoginForm.tsx
│ │ ├── LoginHeader.tsx
│ ├── Dashboard/
│ │ ├── Sidebar.tsx
│ │ └── StatsCard.tsx
│ └── ...
├── utils/
│ ├── Login/
│ ├── Dashboard/
│ └── shared/
├── types/
│ ├── Login/
│ ├── api/
│ └── shared/
```

### 레이어드 구조 + 기능 응집 기반 구조 + MVVM 구조

- 레이어드: 컴포넌트, 유틸, 타입 등 역할별 디렉토리 존재
- 기능 응집 기반: 각 역할 디렉토리 내부가 페이지 단위로 나뉘어 있음.
- 관심사 분리: UI는 components/, 로직은 utils/, 타입은 types/로 나뉨.
- api 호출하는 axios 코드를 따로 모아두고, 페이지별 호출하도록 useQuery 훅들을 따로 분리하고 컴포넌트에서 호출해서 사용 (MVVM)
