# 4장. 리액트 컴포넌트 설계하기

## 1. 단일 책임 원칙

🚀 단일 책임 원칙(SRP: Single Responsibility Principle): 하나의 컴포넌트는 하나의 역할만 수행해야 한다.

예시 코드

```tsx
import React from "react";
import fetchPostById from "./fetchPostById";

interface PostType {
  id: string;
  title: string;
  summary: string;
}

const BlogPost = ({ id }: { id: string }) => {
  const [post, setPost] = useState<PostType>(EmptyBlogPost);  

  useEffect(() => {
    fetchPostById(id).then((post) => setPost(post))'
  },[id]);

  const handleClick = () => {
    setisLiked(!isLiked);
  }

  return (
    <div>
      <h2>{post.title}</h2>
      <p>{post.summary}</p>
      <button onClick={handleClick}>{isLiked ? 'UnLike' : 'Like'}</button>
    </div>
  );
};

export default BlogPost;
```

지금 BlogPost를 보면, 개별 id에 따라는 게시물 변화 / 좋아요 눌렀을 때의 ui 변화 / 새로운 게시물 fetch하기 와 같이 여러 기능을 수행한다.
단일 책임 원칙을 위반하고 있음.

"하나의 컴포넌트가 하나의 책임만 가진다" 는 룰을 지키기 위해서느 아래와 같이 바꿀 수 있을듯

나라면 일단, 데이터 패치 영역은 별도의 파일로 분리 + tanstack query를 사용할 것 같다.

```ts
////////////////////////
// useGetPostDetail.ts
/////////////////////////

import { useQuery } from '@tanstack/react-query'

const useGetPostDetail = ({id}) => {
  const { data: post, isPending, isError } = useQuery({
    queryKey: ['post-detail', id],
    queryFn: async () => getPostDetail(id)
  })

  return {
    post,
    isPending: isLoading,
    isError
  }
}


/////////////////////////
// LikedButton.tsx
/////////////////////////

export const LikedButton = () => {
  const [liked, setLiked] = useState(false);

  const handleClick = () => {
    setisLiked(!isLiked);
  }

  return (
    <button onClick={handleClick}>{isLiked ? 'UnLike' : 'Like'}</button>
  )
}

/////////////////////////
// BlogPost.tsx
/////////////////////////
import React from 'react';
import LikedButton from './LikedButton'l

export const BlogPost = ({ id }: { id: string }) => {
  const { post, isLoading, isError } = useGetPostDetail(id);

  if(isLoading) {
    return <div>Loading...</div>
  }

  return (
    <div>
      <h2>{post.title}</h2>
      <p>{post.summary}</p>
      <LikedButton/>
    </div>
  );
};


```


## 2. 중복 배제 원칙

🚀 DRY(Don't Repeat Yourself) 원칙 : 코드 안에서 중복은 최대한 줄이기

재사용 할 수 있는 컴포넌트나 함수들은 재사용 하자.
예를 들어, 상품 목록 페이지에서 개별 상품 리스트들과 쇼핑 카트에 담기는 개별 상품들을 노출해주어야 할 때,

<img width="369" height="560" alt="Monosnap Untitled Diagram - draw … 2025-08-31 17-23-36" src="https://github.com/user-attachments/assets/abba8bc9-255b-4346-9d5c-d7ef9d573bbd" />

상품 개별 항목을 재활용 할 수 있을 것으로 보인다.

```tsx
// ProductList.tsx
import "./product.css";

const ProductList = ({
  products,
  addToCart,
}: {
  products: Product[];
  addToCart: (id: string) => void;
}) => (
  <div>
    <h2>Product List</h2>
    {products.map((product) => (
      <div key={product.id} className="product">
        <img src={product.image} alt={product.name} />
        <div>
          <h2>{product.name}</h2>
          <p>{product.price}</p>
          <button onClick={() => addToCart(product.id}}>Add to Cart</button>
        </div>
      </div>
    ))}
  </div>
);

export default ProductList;

// Cart.tsx
const Cart = ({
  cartItems,
  removeFromCart,
}: {
  cartItems: Product[];
  removeFromCart: (id: string) => void;
}) => (
  <div>
    <h2>Shopping Cart</h2>
    {cartItems.map((item) => (
      <div key={item.id} className="item">
        <img src={item.image} alt={item.name} />
        <div>
          <h2>{item.name}</h2>
          <p>{item.price}</p>
          <button onClick={() => removeFromCart(item.id}}>Remove From Cart</button>
        </div>
      </div>
    ))}
  </div>
);

export default Cart;
```

리스트를 열거하는 부분이 중복되어 보인다.
이 부분을 공통 로직으로 분리할 수 있을 것 같다.

```tsx
type ProductType = {
  item: Product;
  trigger: {
    name: string;
    action: (id?: string) => void;
  }
}
export const ProductItem = ({item, trigger}: ProuctType) => {

  return (
    <div key={item.id} className="item">
        <img src={item.image} alt={item.name} />
        <div>
          <h2>{item.name}</h2>
          <p>{item.price}</p>
          <button onClick={() => trigger.action(item.id}}>{trigger.name}</button>
        </div>
    </div>
  )
}
```

## 3. 합성 활용하기

처음에는 합성이 Compound Pattern 인줄 알았는데, 아닌듯하다.

아래 예시 처럼, 여러 컴포넌트들을 각각 분리하고, 분리된 컴포넌트들이 모여있는 컴포넌트를 합성 컴포넌트라 지칭한다.

- 관심사 분리
- 가독성
- 테스트 용이: 명확한 관심사 분리는 개별 컴포넌트의 테스트를 더 수월하게 할 수 있도록 도와준다.
- 높은 재사용성: 개별 컴포넌트(UserProfile, FriendList, PostList)를 재활용 할 수 있다.

```tsx
import { UserDashboardProps } from "./types";
import { UserProfile } from "./UserProfile";
import { FriendList } from "./FriendList";
import { PostList } from "./PostList";

function UserDashboard({ user, posts }: UserDashboardProps) {
  return (
    <div>
      <UserProfile user={user} />
      <FriendList friends={user.friends} />
      <PostList posts={posts} />
    </div>
  );
}

export default UserDashboard;
```

## 4. 컴포넌트 설계 원칙의 결합

그러나 현실은 앞에서 말한 것처럼 딱 잘라서 구현할 수 있는게 아니라는 것 즈음은 숙련된 프론트엔드 개발자들이라면 공감할 것이다.

다음 예시를 통해 같이 생각해보면 좋을듯 하다.

Page 컴포넌트에는 헤더, 사이드바, 본문 영역이 있다.
새로운 기능이 추가될 때마다 props가 점차 길어지는 상황을 마주한다.

```tsx
type PageProps = {
  headerTitle: string;
  headerSubtitle: string;
  sidebarLinks: string[];
  isLoading: boolean;
  mainContent: React.ReactNode;
  onHeaderClick: () => void;
  onSidebarLinkClick: (link: string) => void;
}

function Page({
  headerTitle,
  headerSubtitle,
  sidebarLinks,
  isLoading,
  mainContent,
  onHeaderClick,
  onSidebarLinkClick,
}: PageProps) {
  return (
    <div>
      <header onClick={onHeaderClick}>
        <h1>{headerTitle}</h1>
        <h2>{headerSubtitle}</h2>
      </header>
      <aside>
        <ul>
          {sidebarLinks.map((link) => (
            <li key={link} onClick={() => onSidebarLinkClick(link)}>
              {link}
            </li>
          )}
        </ul>
      </aside>
      {!isLoading && <main>{mainContent}</main>}
    </div>
  )
}
```

본문에서는 props가 통상 5개 이상이 넘으면 분리가 필요하다고 말한다.
각 props의 용도를 시간이 지날수록 까먹기가 쉽고, 잘못된 props를 전달하게 되거나 전달 순서가 틀릴 수 있기 때문이다.

일단 위 페이지에서 세 덩어리로 나눈다면 `header`, `sidebar`, `main` 정도의 영역이 되겠다.

1) 헤더 쪼개기
```tsx
type HeaderProps = {
  headerTitle: string;
  headerSubtitle: string;
  onHeaderClick: () => void;
}

export const Header = (props: HeaderProps) => {
  const { headerTitle, headerSubtitle, onHeaderClick } = props;

  return (
      <header onClick={onHeaderClick}>
        <h1>{headerTitle}</h1>
        <h2>{headerSubtitle}</h2>
      </header>
  )
}
```
2) 사이드바 쪼개기

```tsx
type SidebarProps = {
 sidebarLinks: string[];
  onSidebarLinkClick: (link: string) => void;
}

export const Sidebar = (props: SidebarProps) => {
  const {sidebarLinks, onSidebarLinkClick} = props;

  return (
    <aside>
      <ul>
        {sidebarLinks.map((link) => (
          <li key={link} onClick={() => onSidebarLinkClick(link)}>
            {link}
          </li>
        )}
      </ul>
    </aside>
  )
}
```
3) 메인 쪼개기
```tsx
export const Main = ({
  isLoading,
  mainContent
}: {
  isLoading: boolean,
  mainContent: React.ReactNode
}) => {
  return (
    {!isLoading && <main>{mainContent}</main>}
  )
}
```

4) 페이지에서 개별 컴포넌트 (1~3) 로드하기

```tsx
function Page({
  headerTitle,
  headerSubtitle,
  sidebarLinks,
  isLoading,
  mainContent,
  onHeaderClick,
  onSidebarLinkClick,
}: PageProps) {
  return 
    <div>
      <Header {..각각의 props들} />
      <Sidebar {..각각의 props들} />
      <Main {..각각의 props들}/>
    </div>
  )
}
```

🧐 흐음 그래도 여전히 page에는 props들이 많다.
컴포넌트에 넘겨주어야 하는 props들도 주렁주렁..

각 개별 컴포넌트의 인스턴스를 props으로 전달받아서 처리한다.
슬롯처럼 header, sidebar, main의 위치를 뚫어놓는 패턴임.

```tsx
type PageProps = {
  header: React.ReactNode;
  sidebar: React.ReactNode;
  main: React.ReactNode;
};

function Page({ header, sidebar, main }: PageProps) {
  return (
    <div>
      {header}
      {sidebar}
      {main}
    </div>
  );
}
```

```tsx

const MyPage = () => {
  return (
    <Page
      header={<header>hello world</header>}
      sidebar={<aside>sidebar</aside>}
      main={<main>hi</main>}
    />
  )
}
```
