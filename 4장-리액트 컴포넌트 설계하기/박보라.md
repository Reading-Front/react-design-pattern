# 4장. 리액트 컴포넌트 설계하기

## 1. 단일 책임 원칙

🚀 단일 책임 원칙(SRP: Single Responsibility Principle): 하나의 컴포넌트는 하나의 역할만 수행해야 한다.

예시 코드

```tsx
import React from "react";
import fetchPostById from "./fetchPostById";

interface PostType {
  id: string;
  title: string;
  summary: string;
}

const BlogPost = ({ id }: { id: string }) => {
  const [post, setPost] = useState<PostType>(EmptyBlogPost);  

  useEffect(() => {
    fetchPostById(id).then((post) => setPost(post))'
  },[id]);

  const handleClick = () => {
    setisLiked(!isLiked);
  }

  return (
    <div>
      <h2>{post.title}</h2>
      <p>{post.summary}</p>
      <button onClick={handleClick}>{isLiked ? 'UnLike' : 'Like'}</button>
    </div>
  );
};

export default BlogPost;
```

지금 BlogPost를 보면, 개별 id에 따라는 게시물 변화 / 좋아요 눌렀을 때의 ui 변화 / 새로운 게시물 fetch하기 와 같이 여러 기능을 수행한다.
단일 책임 원칙을 위반하고 있음.

"하나의 컴포넌트가 하나의 책임만 가진다" 는 룰을 지키기 위해서느 아래와 같이 바꿀 수 있을듯

나라면 일단, 데이터 패치 영역은 별도의 파일로 분리 + tanstack query를 사용할 것 같다.

```ts
////////////////////////
// useGetPostDetail.ts
/////////////////////////

import { useQuery } from '@tanstack/react-query'

const useGetPostDetail = ({id}) => {
  const { data: post, isPending, isError } = useQuery({
    queryKey: ['post-detail', id],
    queryFn: async () => getPostDetail(id)
  })

  return {
    post,
    isPending: isLoading,
    isError
  }
}


/////////////////////////
// LikedButton.tsx
/////////////////////////

export const LikedButton = () => {
  const [liked, setLiked] = useState(false);

  const handleClick = () => {
    setisLiked(!isLiked);
  }

  return (
    <button onClick={handleClick}>{isLiked ? 'UnLike' : 'Like'}</button>
  )
}

/////////////////////////
// BlogPost.tsx
/////////////////////////
import React from 'react';
import LikedButton from './LikedButton'l

export const BlogPost = ({ id }: { id: string }) => {
  const { post, isLoading, isError } = useGetPostDetail(id);

  if(isLoading) {
    return <div>Loading...</div>
  }

  return (
    <div>
      <h2>{post.title}</h2>
      <p>{post.summary}</p>
      <LikedButton/>
    </div>
  );
};


```


## 2. 중복 배제 원칙

🚀 DRY(Don't Repeat Yourself) 원칙 : 코드 안에서 중복은 최대한 줄이기

재사용 할 수 있는 컴포넌트나 함수들은 재사용 하자.
예를 들어, 상품 목록 페이지에서 개별 상품 리스트들과 쇼핑 카트에 담기는 개별 상품들을 노출해주어야 할 때,

<img width="369" height="560" alt="Monosnap Untitled Diagram - draw … 2025-08-31 17-23-36" src="https://github.com/user-attachments/assets/abba8bc9-255b-4346-9d5c-d7ef9d573bbd" />

상품 개별 항목을 재활용 할 수 있을 것으로 보인다.

```tsx
// ProductList.tsx
import "./product.css";

const ProductList = ({
  products,
  addToCart,
}: {
  products: Product[];
  addToCart: (id: string) => void;
}) => (
  <div>
    <h2>Product List</h2>
    {products.map((product) => (
      <div key={product.id} className="product">
        <img src={product.image} alt={product.name} />
        <div>
          <h2>{product.name}</h2>
          <p>{product.price}</p>
          <button onClick={() => addToCart(product.id}}>Add to Cart</button>
        </div>
      </div>
    ))}
  </div>
);

export default ProductList;

// Cart.tsx
const Cart = ({
  cartItems,
  removeFromCart,
}: {
  cartItems: Product[];
  removeFromCart: (id: string) => void;
}) => (
  <div>
    <h2>Shopping Cart</h2>
    {cartItems.map((item) => (
      <div key={item.id} className="item">
        <img src={item.image} alt={item.name} />
        <div>
          <h2>{item.name}</h2>
          <p>{item.price}</p>
          <button onClick={() => removeFromCart(item.id}}>Remove From Cart</button>
        </div>
      </div>
    ))}
  </div>
);

export default Cart;
```

리스트를 열거하는 부분이 중복되어 보인다.
이 부분을 공통 로직으로 분리할 수 있을 것 같다.

```tsx
type ProductType = {
  item: Product;
  trigger: {
    name: string;
    action: (id?: string) => void;
  }
}
export const ProductItem = ({item, trigger}: ProuctType) => {

  return (
    <div key={item.id} className="item">
        <img src={item.image} alt={item.name} />
        <div>
          <h2>{item.name}</h2>
          <p>{item.price}</p>
          <button onClick={() => trigger.action(item.id}}>{trigger.name}</button>
        </div>
    </div>
  )
}
```

## 3. 합성 활용하기

합성이 처음에 Compound Pattern 인줄 알았는데, 아닌듯하다.

아래 예시 처럼, 여러 컴포넌트들을 각각 분리하고, 분리된 컴포넌트들이 모여있는 컴포넌트를 합성 컴포넌트라 지칭한다.

- 관심사 분리
- 가독성
- 테스트 용이: 명확한 관심사 분리는 개별 컴포넌트의 테스트를 더 수월하게 할 수 있도록 도와준다.
- 높은 재사용성: 개별 컴포넌트(UserProfile, FriendList, PostList)를 재활용 할 수 있다.

```tsx
import { UserDashboardProps } from "./types";
import { UserProfile } from "./UserProfile";
import { FriendList } from "./FriendList";
import { PostList } from "./PostList";

function UserDashboard({ user, posts }: UserDashboardProps) {
  return (
    <div>
      <UserProfile user={user} />
      <FriendList friends={user.friends} />
      <PostList posts={posts} />
    </div>
  );
}

export default UserDashboard;
```

## 4. 컴포넌트 설계 원칙의 결합
