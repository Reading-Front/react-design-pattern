# 4장. 리액트 컴포넌트 설계하기

## 1. 단일 책임 원칙

단일 책임 원칙(SRP: Single Responsibility Principle): 하나의 컴포넌트는 하나의 역할만 수행해야 한다.

예시 코드

```tsx
import React from "react";
import fetchPostById from "./fetchPostById";

interface PostType {
  id: string;
  title: string;
  summary: string;
}

const BlogPost = ({ id }: { id: string }) => {
  const [post, setPost] = useState<PostType>(EmptyBlogPost);  

  useEffect(() => {
    fetchPostById(id).then((post) => setPost(post))'
  },[id]);

  const handleClick = () => {
    setisLiked(!isLiked);
  }

  return (
    <div>
      <h2>{post.title}</h2>
      <p>{post.summary}</p>
      <button onClick={handleClick}>{isLiked ? 'UnLike' : 'Like'}</button>
    </div>
  );
};

export default BlogPost;
```

지금 BlogPost를 보면, 개별 id에 따라는 게시물 변화 / 좋아요 눌렀을 때의 ui 변화 / 새로운 게시물 fetch하기 와 같이 여러 기능을 수행한다.
단일 책임 원칙을 위반하고 있음.

"하나의 컴포넌트가 하나의 책임만 가진다" 는 룰을 지키기 위해서느 아래와 같이 바꿀 수 있을듯

나라면 일단, 데이터 패치 영역은 별도의 파일로 분리 + tanstack query를 사용할 것 같다.

```ts
////////////////////////
// useGetPostDetail.ts
/////////////////////////

import { useQuery } from '@tanstack/react-query'

const useGetPostDetail = ({id}) => {
  const { data, isPending, isError } = useQuery({
    queryKey: ['post-detail', id],
    queryFn: async () => getPostDetails(id)
  })
}


/////////////////////////
// LikedButton.tsx
/////////////////////////

export const LikedButton = () => {
  const [liked, setLiked] = useState(false);

  const handleClick = () => {
    setisLiked(!isLiked);
  }

  return (
    <button onClick={handleClick}>{isLiked ? 'UnLike' : 'Like'}</button>
  )
}

/////////////////////////
// BlogPost.tsx
/////////////////////////




```



## 2. 중복 배제 원칙

## 3. 합성 활용하기

## 4. 컴포넌트 설계 원칙의 결합
