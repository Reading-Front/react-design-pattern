# 4장 리액트 컴포넌트 설계하기

## 4.1 단일 책임 원칙(Single Responsibility Principle, SRP)

소프트웨어 공학의 기본 개념 중 하나로 함수, 클래스 혹은 리액트 컴포넌트는 변경해야 할 이유가 단 하나만 있어야 함을 의미합니다.
즉, 하나의 컴포넌트는 하나의 작업이나 기능만을 수행하는 것이 이상적입니다. 이 원칙을 따르면 코드 가독성이 높아지고, 유지보수와 테스트 및 디버깅도 쉬워집니다.

```tsx
import React, { useState, useEffect } from 'react'
import fetchPostByld from './fetchPostByld'

interface PostType {
  id: string
  title: string
  summary: string
}
const BlogPost = ({ id }: { id: string }) => {
  const [post, setPost] = useState<PostType>(EmptyBlogPost)
  const [isLiked, setlsLiked] = useState(false)
  useEffect(() => {
    fetchPostByld(id).then((post) => setPost(post))
  }, [id])
  const handleClick = () => {
    setIsLiked(!isLiked)
  }
  return (
    <div>
      <h2>{post.title}</h2>
      <p>{post.summary}</p>
      <button onClick={handleClick}>{isLiked ? 'Unlike' : 'Like'}</button>
    </div>
  )
}
```

이 코드는 데이터 가져오기, 블로그 포스트 표시, 좋아요 기능 관리까지 3가지 동작을 하나의 컴포넌트에서 수행하기 때문에 단일 책임 원칙을 위반합니다.

```tsx
const useFetchPost = (id: string): PostType => {
  const [post, setPost] = useState<PostType>(EmptyBlogPost)

  useEffect(() => {
    fetchPostByld(id).then((post) => setPost(post))
  }, [id])

  return post
}

const LikeButton: React.FC = () => {
  const [isLiked, setlsLiked] = useState(false)

  const handleClick = () => {
    setIsLiked(!isLiked)
  }

  return <button onClick={handleClick}>{isLiked ? 'Unlike' : 'Like'}</button>
}

const BlogPost = ({ id }: { id: string }) => {
  const post = useFetchPost(id)
  return (
    <div>
      <h2>{post.title}</h2>
      <p>{post.summary}</p>
      <LikeButton />
    </div>
  )
}
```

- useFetchPost는 블로그 포스트 데이터를 가져오는 사용자 정의 혹입니다.
- LikeButton은 ‘좋아요’ 기능을 다루는 컴포넌트입니다.
- BlogPost는 이제 블로그 푸人트 내용과 LikeButton 렌더링만 맡게 됩니다.

각 파트는 하나의 책임을 가지며 독립적인 테스트와 수정이 가능합니다. 이는 코드베이스를 다루기 수월하게 합니다.

## 4.2 중복 배제 원칙

중복 배제(Don't repeat yourself, DRY) 원칙은 소프트웨어 개발의 기본 개념 중 하나로, 코드 안에서 중복을 줄이는 것이 목적입니다. 이 원칙을 지키면 유지보수성과 가독성이 높아지고 테스트하기 쉬워지며 로직 중복으로 인해 발생하는 버그를 방지할 수 있습니다.

<img width="611" height="461" alt="Image" src="https://github.com/user-attachments/assets/39e111d8-c024-4e39-a552-f3da9329a612" />

```tsx
type Product = {
  id: string
  name: string
  image: string
  price: number
}

const ProductList = ({
  products,
  addToCart,
}: {
  products: Product[]
  addToCart: (id: string) => void
}) => (
  <div>
    <h2>Product List</h2>
    {products.map((product) => (
      <LineItem
        key={product.id}
        product={product}
        performAction={addToCart}
        label='Add to Cart'
      />
    ))}
  </div>
)

const LineItem = ({
  product,
  performAction,
  label,
}: {
  product: Product
  performAction: (id: string) => void
  label: string
}) => {
  const { id, image, name, price } = product

  return (
    <div key={id} className='product'>
      <img src={image} alt={name} />
      <div>
        <h2>{name}</h2>
        <p>${price}</p>
        <button onClick={() => performAction(id)}>{label}</button>
      </div>
    </div>
  )
}

const Cart = ({
  cartItems,
  removeFromCart,
}: {
  cartItems: Product[]
  removeFromCart: (id: string) => void
}) => (
  <div>
    <h2>Shopping Cart</h2>
    {cartItems.map((item) => (
      <LineItem
        key={item.id}
        product={item}
        performAction={removeFromCart}
        label='Remove from Cart'
      />
    ))}
  </div>
)
```

```tsx
const products: Product[] = [
  {
    id: 'p1',
    name: 'iPad',
    image: 'https://m.media-amazon.com/images/I/31NJHAAviGL._MCnd_AC_.jpg',
    price: 666,
  },
  {
    id: 'p2',
    name: 'iPhone',
    image: 'https://m.media-amazon.com/images/I/31MX9scnEzL._MCnd_AC_.jpg',
    price: 777,
  },
]

const MyShop = () => {
  const [items, setItems] = useState<Product[]>([])
  const addToItems = (id: string) =>
    setItems([...items, products.find((p) => p.id === id)!])

  const removeFromItems = (id: string) => {
    setItems(items.filter((p) => p.id !== id))
  }

  return (
    <Page
      header={
        <Header
          title='My application'
          subtitle='Product page'
          onClick={() => console.log('toggle header')}
        />
      }
      sidebar={
        <Sidebar
          links={['Home', 'About', 'Contact']}
          onLinkClick={() => console.log(`toggle sidebar`)}
        />
      }
      main={
        <div className='my-shop'>
          <ProductList products={products} addToCart={addToItems} />
          <Cart cartItems={items} removeFromCart={removeFromItems} />
        </div>
      }
    />
  )
}
```

Cart 컴포넌트도 LineItem 컴포넌트를 재사용하여 이미지, 상품명, 가격 등의 상품 상세 정보를 렌더링하는 비슷한 구조를 가집니다. 이는 중복 배제 원칙에 따라 좀 더 유지보수하기 쉽고 재사용성을 높인 접근법입니다. 변경은 한 곳에서만 일어나므로 버그가 발생할 가능성이 줄어듭니다. 만약 LineItem에 새로운 기능을 추가한다면 하나의 컴포넌트만 수정하면 됩니다.

중복 배제 원칙은 코드의 중복을 제거하여 불일치와 버그의 가능성을 줄여줍니다. 코드 중복을 피하면, 기능 변경을 한 곳에서 해결할 수 있기 때문에 유지보수가 단순해질 수 있었습니다.

## 4.3 합성 활용하기

리액트에서 합성(composition)은 컴포넌트를 설계하는 자연스러운 패턴입니다.
예를 들어 사용자 정보를 표시하는 UserDashboard 컴포넌트의 프로필에는 아바타 이미지, 이름, 사용자의 친구 목록, 최근 포스트 목록이 표시됩니다.

```tsx
import { UserDashboardProps } from './types'
import { UserProfile } from './UserProfile'
import { FriendList } from './FriendList'
import { PostList } from './PostList'

function UserDashboard({ user, posts }: UserDashboardProps) {
  return (
    <div>
      <UserProfile user={user} />
      <FriendList friends={user.friends} />
      <PostList posts={posts} />
    </div>
  )
}

export default UserDashboard
```

UserDashboard 컴포넌트는 여러 가지 장점이 있습니다.

- 관심사 분리: 컴포넌트의 여러 다른 영역들을 UserProfile, FriendList, PostList 등으로 분리해서 각각의 컴포넌트가 하나의 역할을 담당합니다. 덕분에 유지보수가 쉬워집니다.
- 더 나은 가독성: 리팩터링한 UserDashboard는 가독성이 높아 이해하기 쉽습니다. 사용자 프로필, 친구 목록, 포스트 목록 등 컴포넌트가 어떤 것을 렌더링할지 명확합니다. 각 영역이 어디서 어떻게 렌더링돠는지 세세하게 살펴볼 필요가 없습니다.
- 높은 재사용성: UserProfile, FriendList. PostList 컴포넌트를 애플리케이션의 다른 영역에서도 사용할 수 있기 때문에 중복을 줄일 수 있습니다.
- 테스트의 용이함: 작고 하나의 책임을 가진 컴포넌트는 상호작용이 복잡하지 않고 의존하는 코드가 적어 테스트하기 쉽습니다.

## 4.4 컴포넌트 설계 원칙의 결합

지금까지 단일 책임 원칙과 중복 배제 원칙, 합성에 대해 자세히 알아보았습니다. 하지만 실전 코딩 상황은 생각보다 더 복잡하며. 코드 가독성과 유지보수성을 높이기 위해 여러 원칙을 동시에 적용해야만 합니다.

Page 컴포넌트 예제를 살펴보겠습니다. 헤더, 사이드바, 본문 영역의 상태와움직임을 관리하는 여러 가지 역할이 있고, 각각의 영역을 위한 prop이 많이 있습니다. 기존 코드베이스를 복사해서 구현할 때 이런 코드를 흔히 접하게 됩니다. 새로운 기능이 더해질 때마다 prop 목록 또한 늘어납니다.

```tsx
type PageProps = {
  headerTitle: string
  headerSubtitle: string
  sidebarLinks: string[]
  isLoading: boolean
  mainContent: React.ReactNode
  onHeaderClick: () => void
  onSidebarLinkClick: (link: string) => void
}

function Page({
  headerTitle,
  headerSubtitle,
  sidebarLinks,
  mainContent,
  isLoading,
  onHeaderClick,
  onSidebarLinkClick,
}: PageProps) {
  return (
    <div>
      <header onClick={onHeaderClick}>
        <h1>{headerTitle}</h1>
        <h2>{headerSubtitle}</h2>
      </header>
      <aside>
        <ul>
          {sidebarLinks.map((link) => (
            <li key={link} onClick={() => onSidebarLinkClick(link)}>
              {link}
            </li>
          ))}
        </ul>
      </aside>
      {!isLoading && <main>{mainContent}</main>}
    </div>
  )
}
```

Page 컴포넌트를 만들었습니다. 클릭할 수 있는 헤더, 링크가 연결된 사이드바, 본문 영역이 있는 페이지를 렌더링합니다.

PageProps에 대해 자세히 살펴봅니다.

- headerTitle: 페이지 헤더의 제목을 나타내는 문자열입니다.
- headersubtitle： 페이지 헤더의 부제목을 나타내는 문자열입니다.
- sidebarLinks: 문자열 배열로 각각의 문자가 페이지 사이드바의 링크 주소입니다.
- isLoading： 본문이 준비되었는지 여부를 나타냅니다.
- mainContent: 컴포넌트 HTML 요소 null 등 페이지의 본문을 나타내는 어떤 리액트 노드라도 가능합니다.
- onHeaderClick: 페이지 헤더 영역을 클릭하면 실행되는 함수입니다.
- onSidebarLinkClick: 사이드바의 링크를 클릭하면 실행돠는 함수로 클릭한 링크를 인자로 함수를 호출합니다.

Page 컴포넌트는 많은 속성을 가진 prop으로 여러 가지 역할을 하며, 컴포넌트가 보통 5개 이상의 prop을 가진다면 분리가 필요합니다. 각 prop의 용도를 기억하기 쉽지 않을 수 있고, 잘못된 prop을 전달하거나 전달 순서가 틀릴 수 있기 때문입니다.

prop을 사용하는 방법에 따라 분류할 수 있습니다. headerTitle, headerSubtitle, onHeaderClick prop은 하나의 그룹으로 분리할 수 있습니다. isLoading이나 mainContent는 다른 그룹으로 나눕니다.

커다란 컴포넌트를 작게 나누는 방법은 다양합니다. 정보가 서로 관련되어 있다면 하나의 그룹으로 묶고 이 단위로 새로운 컴포넌트를 만듭니다.

Page 컴포넌트는 지나치게 많은 역할을 맡고 있어서 prop 역시 늘어날 수밖에 없었습니다. 그리고 많은 데이터를 여러 계층에 전달해야 하는 Prop Drilling 문제가 있었습니다. 이 설계는 구성하기 복잡할 뿐만 아니라 유지보수하기도 어렵습니다.

```tsx
import React from 'react'

type HeaderProps = {
  title: string
  subtitle: string
  onClick: () => void
}

const Header = ({ title, subtitle, onClick }: HeaderProps) => {
  return (
    <header onClick={onClick}>
      <h1>{title}</h1>
      <h2>{subtitle}</h2>
    </header>
  )
}

type SidebarProps = {
  links: string[]
  onLinkClick: (link: string) => void
}

const Sidebar = ({ links, onLinkClick }: SidebarProps) => {
  return (
    <aside>
      <ul>
        {links.map((link) => (
          <li key={link} onClick={() => onLinkClick(link)}>
            {link}
          </li>
        ))}
      </ul>
    </aside>
  )
}

type MainProps = {
  isLoading: boolean
  content: React.ReactNode
}

const Main = ({ isLoading, content }: MainProps) => {
  return <>{!isLoading && <main>{content}</main>}</>
}

type PageProps = {
  header: React.ReactNode
  sidebar: React.ReactNode
  main: React.ReactNode
}

function Page({ header, sidebar, main }: PageProps) {
  return (
    <div>
      {header}
      {sidebar}
      {main}
    </div>
  )
}

export { Header, Sidebar, Main, Page }
```

이러한 문제점들을 해결하고자 여러 기본 설계 원칙들을 적용하였습니다. 단일 책임 원칙을 기반으로, 거대한 Page 컴포넌트를 작고 다루기 쉬운 Header, Sidebar, Main 컴포넌트로 분리하는 리팩터링 과정을 거쳤습니다. 서브 컴포넌트가 각자의 역할을 담당하게 하고 그에 필요한prop만을 전달받아 구조가 단순해졌습니다.

이렇게 컴포넌트를 분리한 뒤에, 합성을 통해 Page 컴포넌트가 분리한 서브 컴포넌트를 prop으로 전달받도록 수정했습니다. 이 방법은 Page 컴포넌트를 사용하는 곳에서 서브 컴포넌트를 prop을 통해 직접 제공하도록 하여 Prop Drilling 문제를 확연하게 줄였습니다. 이 리팩터링 과정은 Page 컴포넌트를 간소화하여 깔끔하고 관리하기 쉬운 코드베이스로 만들어주었습니다. Prop Drilling 문제를 효과적으로 해결하기 위해 컴포넌트 합성과 단일 책임원칙을 활용하였습니다.

이 장에서는 리액트 컴포넌트 설계와 개선을 위한 단일 책임 원칙, 중복 배제 원칙, 컴포넌트
합성에 대해 알아보았습니다. 이러한 원칙들을 적용하면 깔끔하고 유지보수가 쉬운 코드베이
스를 구축할 수 있으며, 이는 리액트 애플리케이션의 견고한 기반이 됩니다.
