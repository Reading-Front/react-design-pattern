# 5장. 리액트 테스팅

## 프론트에서의 테스트 기법

정적 분석 > 단위 테스트 > 통합 테스트 > 시각적 회귀 테스트 > E2E 테스트

### 정적 검사

Linting Tool 활용

로우 레벨에서의 일관적인 코드 스타일 유지, 오류 구문 검사, 타입 체크.

코드를 실행시키지 않고 구문을 분석하는 과정.



### 단위 테스트

jset를 사용해서 함수, 메소드 등 컴포넌트와 같은 기본 단위 코드가 격리된 환경에서 예상대로 동작하는지 검증.

`test` : 기본적인 테스트 구문 
  - 테스트 설명 문자열과 콜백함수를 인자로 받음.
```ts
function add(a: number, b:number) {
  return a + b;
}

test('add adds numbers', () => {
  expect(add(1,)).toBe(3)
});
```
  
`it` : `~이다` 영어 구문 처럼 표현할 수 있는 구문.
```ts
it('adds 1+2 to equal 3', () => expect(1 + 2).toBe(3))
```

`describe` : 테스트 그룹, 테스트를 연관된 덩어리로 묶을 수 있는 구문

```ts
describe('math functions', () => {
  it('adds positive numbers', () => {
    expect(add(1, 2)).toBe(3)
  });

  it('adds negative numbers', () => {
    expect(add(-1, -2)).toBe(-3)
  });
}
```

### 리액트 컴포넌트 테스트

@testing-library/react로 컴포넌트의 기본 동작 테스트 가능.

```tsx
type SectionProps = {
  heading: string;
  content: string;
};

const Section = ({ heading, content }: SectionProps) => {
  return (
    <article>
      <h1>{heading}</h1>
      <p>{content}</p>
    </article>
  );
};

export { Section };
```

- 테스트 코드

```tsx
// Section.test.tsx
import React from "react";
import { Section } from "./Section";
import { render, expect } from "@testing-library/react";

describe("Section 컴포넌트 테스트", () => {
  it("Section 컴포넌트가 Props에 따라 잘 렌더링 되는가?", () => {
    render(<Section heading="Hello" content="World" />);

    expect(screen.getByText("Hello")).toBeInDocument();
    expect(screen.getByText("World")).toBeInDocument();
  });
}); 
```

### 통합 테스트

- 여러 단위 컴포넌트들의 상호작용을 검증.
- 서버와 클라이언트 사이의 상호작용 검증.

### E2E 테스트 with Cypress

## 결론

테스트 코드 작성의 이점 : 코드 가독성 및 일관성, 유지 보수성, 코드 검증
