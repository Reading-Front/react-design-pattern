# 리액트 테스팅

## 1. 테스트가 필요한 이유

테스트는 소프트웨어의 안정성과 유지보수성을 높여준다.

테스팅의 장점

- 코드 검증 : 코드가 의도한 방향으로 동작하고 있음을 확실하게 알려준다.
  함수가 주어진 입력값이 따른 결괏값을 반환하고, 컴포넌트가 올바르게 렌더링되며, 애플리케이션이 예상대로 동작하는지 테스트를 통해 확인할 수 있다.
- 회귀 방지 : 애플리케이션을 확장하면서 새로운 코드의 추가로 인해 기존에 잘 동작하던 기능을 깨트릴 수 있다.
  이를 회구라 부른다. 자동화된 테스트는 회귀를 잡아주는 안전망 역할을 한다.
- 리팩터링과 유지보수의 용이함 : 리팩터링이나 레거시 코드를 업데이트하는 과정을 불안하기 마련이다. 테스트는 이러한 불안을 줄여준다. 업데이트나 리팩터링 과정에서 실수로 무언가를 깨트리더도 테스트가 잡아주니 안심할 수 있다.
- 코드 품질에 대한 신뢰 향상 : 잘 작성된 테스트 코드가 뒷받침된다면 코드의 품질을 정량적으로 측정할 수 있다.
- 문서화 : 테스트는 문서로 쓰일 수 있다. 테스트를 통해 함수나 컴포넌트의 수행 동작을 명확히 이해할 수 있고, 새로 합류하는 팀 동료가 프로젝트의 기능 동작을 이해할 수 있다.

## 2. 여러 종류의 테스트 알아보기

- 단위 테스트 : 개별 컴포넌트나 함수의 기능을 격리하여 각각 예상대로 동작하는지를 확인한다.
- 통합 테스트 : 다른 모듈과 서비스들이 원활하게 상호작용하여 함께 잘 동작하는지를 검사한다.
- E2E 테스트 : 전체 애플리케이션의 흐름을 시작부터 종료까지 실제 사용자 행동을 묘사하여 테스트한다. 이를 통해 전체 시스템이 유기적으로 잘 동작하는지를 확인한다.

빠르게 수행이 가능한 단위 테스트는 많은 시나리오를 만들고 자주 실행하여 상세한 피드백을 빠르게 확인해야 한다. 반면 수행 시간이 많이 걸리는 E2E 테스트는 단위 테스트보다 시나리오 수는 적지만, 각 기능들이 유기적으로 동작하는지를 검증해야 한다. 마이크 콘이 고안한 테스트 피라미드에서는 통합 테스트나 E2E 테스트보다 단위 테스트를 더 많이 수행할 것을 권장한다.

하지만 현대의 프런트엔드 개발에서 이 모델은 진화하고 있다. 프런트엔드 애플리케이션의 복잡도가 높아지고 상호작용이 많아지면서, 통합 테스트와 E2E 테스트가 더욱 중요해졌다.

Cypress, Puppeteer와 같은 도구들을 이용하면 브라우저에서의 사용자 행동을 모방하는 E2E 테스트를 쉽게 작성할 수 있다. 또한 리액트 테스팅 라이브러리는 컴포넌트 간의상호작용을 쉽게 확인할 수 있도록 하여 통합 테스트를 더욱 원활하게 해준다.

- 시각적 회귀 테스트 : 웹 애플리케이션의 시각적으로 나타나는 부분을 저장하고 이전 버전과 비교하는 방식이다. 사용자 인터페이스의 의도하지 않은 시각적 오류와 변경 사항이 개발 도중에 발생했을 때, 이러한 유형의 테스트가 특히 유용하다. 각기 다른 시점에서 웹페이지 또는 컴포넌트의 스크린샷이나 스냅샷을 찍어 픽셀 단위로 비교하여 시각적 차이점을 찾아낸다. 차이점이 발견되었을 때는 리뷰가 필요하다고 표시한다. 감지된 변화가 새로운 기능이나 디자인 업데이트로 인한 예상된 변화인지, 아니면 의도치 않은 변화라 수정이 필요한지 리뷰를 진행할 때 결정한다.

- 정적 검사: 프런트엔드 테스팅 방법론 중 정적 검사는 오류를 잡아내고 코딩 표준을 보장하기 위해 코드를 실행시키지 않고 구문을 분석하는 것이다. 구문 오류를 체크하고, 린팅을 통한 코드 표준을 강제하고, 타입 검사를 통해 올바른 데이터 타입을 확인한다. 또한 코드의 복잡도를 분석하고 의존성을 검사하며 보안 취약점을 확인한다.

[발전된 테스트 피라미드]

- E2E 테스트
- 시각적 회귀 테스트
- 통합 테스트
- 단위 테스트
- 정적 검사

## 3. Jest로 하는 개별 단위 테스팅

단위 테스트는 가장 작은 단위이면서 테스트 피라미드의 기본 토대가 된다. 함수, 메서드 또는 컴포넌트와 같은 기본 단위 코드가 격리된 환경에서 예상한 대로 동작을 수행하는지 검증한다. 단위 테스트는 작성하고 실행하기 쉬우며 개발자에게 즉각적인 피드백을 제공한다.
Jest는 페이스북에서 만든 범용 자바스크립트 테스팅 프레임워크로, 단순함에 초점을 맞춘다다. 비동기 테스트, 모킹, 스냅샷 테스팅 등을 지원하고, 기능이 풍부하여 리액트 애플리케이션을 테스트하기에 좋은 선택이다.

### 테스트 작성 예시

```tsx
import { add } from './math'
test('add adds numbers correctly', () => {
  expect(add(l, 2)).toBe(3)
})
```

expect는 Jest에서 제공하는 함수이며 실제 값을 전달받고, toBe는 비교 함수로 실제 값과 기대한 값을 비교한다.

Jest에서 test와 it 함수는 실제로 같은 함수이며 서로 번갈아 가며 사용할 수 있습니다. 각각의 이름은 서로 다른 테스팅 규칙에서 등장했습니다. 팀의 테스팅에 대한 선호와 철학에 따라 맞는 방법을 선택하면 됩니다.

### 테스트 그룹 묶기

서로 관련이 있는 테스트들을 하나의 그룹으로 묶으면 테스트 파일의 가독성이 향상된다.
Jest에서는 describe 함수를 이용하여 테스트 그룹을 묶을 수 있다. 또한 Jest로 describe 블록을 중첩하여 테스트를 좀 더 구조화할 수 있습니다.

```tsx
import { add } from './math'

describe('calculator', () => {
  describe('addition', () => {
    it('adds positive numbers correctly', () => {
      expect(add(1, 2)).toBe(3)
    })

    it('adds negative numbers correctly', () => {
      expect(add(-1, -2)).toBe(-3)
    })

    // More tests...
  })

  describe('subtraction', () => {
    it('subtracts positive numbers', () => {})
  })

  // Other describe blocks for multiplication and division
})
```

### 리액트 컴포넌트 테스트

```tsx
type SectionProps = {
  heading: string
  content: string
}
const Section = ({ heading, content }: SectionProps) => {
  return (
    <article>
      <h1>{heading}</h1>
      <p>{content}</p>
    </article>
  )
}

export { Section }
```

```tsx
import React from 'react'
import '@testing-library/jest-dom'
import { render, screen } from '@testing-library/react'

import { Section } from '../component/Section'

describe('Section', () => {
  it('renders a section with heading and content', () => {
    render(<Section heading='Basic' content='Hello world' />)

    expect(screen.getByText('Basic')).toBeInTheDocument()
    expect(screen.getByText('Hello world')).toBeInTheDocument()
  })
})
```

이 테스트 코드는 @testing-library/react를 사용하여 Section 컴포넌트가 예상대로 동작하는지 검증한다. Basic과 Hello world 텍스트가 HTML 문서에 표시되어야 한다. @testing-library/react에서 제공하는 렌더링 함수는 Section 컴포넌트 안의 heading에 Basic, content에 H이Io world prop을 전달했을 때 HTML을 렌더링한다.

렌더링 이후에 screen.getByText 함수는 Section 컴포넌트로 렌더링된 DOM에서 특정 텍스트를 가진 요소를 조회한다. 그 다음 expect와 toBelnTheDocument는 이 요소의 상태에 대해 단언"하는 데에 쓰인다. DOM에 Basic 텍스트가 있는 요소와 Hello world 텍스트가 있는 요소가 있다고 단언하여, section 컴포넌트가 heading과 content prop을올바르게 렌더링했음을 확인한다.

리액트 컴포넌트에 대한 직관적인 단위 테스트는 테스팅을 시작하기 좋은 시점이다. 하지만 실전의 복잡한 프로젝트에서는 여러 개의 컴포넌트들이 조화롭게 상호작용해야 하는 상황을 만나게 된다. 각각의 개별 컴포넌트들을 자연스럽게 통합하려면 좀 더 포괄적인 테스팅 전략이 필요하다.

## 4. 통합 테스트

통합 테스트는 여러 단위 코드들 사이의 서버와 클라이언트 사이의 상호작용에 대해 검증한다. 통합 테스트의 목적은 시스템의 각기 다른 부분들을 통합하면서 생길 수 있는 문제들을 발견하는 것이다.

- 2개의 개별 컴포넌트 사이의 상호작용을 테스트 - UI 컴포넌트 레벨에서의 통합 테스트
- 프런트엔드 코드와 백엔드 서비스가 자연스럽게 연결되는지 확인

### 예제

[Next] 버튼의 초기 상태는 비활성화 표시가 되어 있습니다. 하지만 사용자가 [Accept the Terms and Conditions]를 체크하면 버튼이 활성화되어 다음으로 넘어갈 수 있습니다.

```tsx
import React from 'react'
import '@testing-library/jest-dom'
import { render, screen } from '@testing-library/react'
import { TermsAndConditions } from '../component/TermsAndConditions'
import userEvent from '@testing-library/user-event'

describe('Terms and Conditions', () => {
  it('이용약관과 조건에 동의하면 [Next] 버튼을 활성화하기', async () => {
    render(<TermsAndConditions />)

    // Next 텍스트를 이용하여 버튼 찾기
    const button = screen.getByText('Next')
    // 비활성화 상태인지 확인하기
    expect(button).toBeDisabled()

    // 체크박스를 역할로 구분하여 찾기
    const checkbox = screen.getByRole('checkbox')
    // 사용자의 체크박스 선택은 act 함수로 감싼 userEvent.click 함수를 통해 시뮬레이션한다.
    // act 함수는 이 동작으로 인한 모든 UI 업데이트가 완료될 때까지 기다린 후 다음 단계로 진행하므로테스트 과정에서 업데이트된 상태를 정확하게 확인할 수 있다.
    await userEvent.click(checkbox)

    // 마지막으로, 체크박스를 클릭한 후에 버튼이 활성화 되는 것을 확인
    expect(button).toBeEnabled()
  })
})
```

TermsAndConditions 컴포넌트

```tsx
import React, { useState } from 'react'

const TheLegalContent = () => {
  return <p>{/*...*/}</p>
}

type CheckBoxProps = {
  label: string
  isChecked: boolean
  onCheck: (event: any) => void
}

const CheckBox = ({ label, isChecked, onCheck }: CheckBoxProps) => {
  return (
    <label>
      <input type='checkbox' checked={isChecked} onChange={onCheck} />
      {label}
    </label>
  )
}

type ButtonProps = {
  type: 'standard' | 'primary' | 'secondary'
  label: string
  disabled?: boolean
}

const Button = ({ label, disabled = true }: ButtonProps) => {
  return (
    <div style={{ margin: '0.5rem 0' }}>
      <button disabled={disabled}>{label}</button>
    </div>
  )
}

const UserConsent = () => {
  const [isChecked, setIsChecked] = useState(false)

  const handleCheckboxChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setIsChecked(event.target.checked)
  }

  return (
    <>
      <CheckBox
        isChecked={isChecked}
        onCheck={handleCheckboxChange}
        label='I accept the terms and conditions'
      />
      <Button type='primary' label='Next' disabled={!isChecked} />
    </>
  )
}

const TermsAndConditions = () => {
  return (
    <div>
      <h2>Terms and Conditions</h2>
      <TheLegalContent />
      <UserConsent />
    </div>
  )
}

export { TermsAndConditions }
```

이 컴포넌트에서 외부로 노출되는 컴포넌트는 TermsAndConditions 하나이다. 이 테스트에서는 jsdom 환경에서 클릭 이벤트를 시작하기 위해 니serEvent.click을 사용한다.

중요한 것은 개별 리액트 컴포넌트에 대한 단위 테스트를 수행하는 것이 아니라, DOM요소 간의 상호작용에 초점을 맞추는 것이다. 여기서는 모든 기능을 지원하는 브라우저를 사용하지 않고, 메모리 위에서 동작하는 헤드리스 브라우저인 jsdom을 사용한다. 제한된 환경에서 수행하는 통합 테스트일지라도, 클릭 이벤트와 버튼 활성화가 예상한 대로 동작하는지를 확인하는 데는 충분하다.

> jsdom은 자바스크립트 기반의 헤드리스 브라우저로 실제 웹 브라우저와 유사한 테스팅 환경을 만들 때 사용합니다. 자바스크립트로 HTML, DOM. CSS와 같은 웹 표준을 구현합니다.

## 5. Cypress를 이용한 E2E 테스트

E2E 테스트는 테스트 피라미드의 가장 상위에 있다. E2E 테스트는 실제 사용자 흐름과 상호작용을 묘사하여, 시스템 전체를 테스트한다. 이 테스트는 사용자 인터페이스부터 백엔드 시스템까지 애플리케이션의 모든 부분이 함께 잘 동작하는지를 검증한다.

### Cypress 실습

- cypress
  - downloads : Cypress 테스트 과정에서 다운로드 파일들이 저장되는 위치
  - e2e : E2E 테스트 파일들
    - quote-of-the-day.spec.cy.js : 오늘의 명언 기능을 테스트하기 위해 Cypress 마법사가 생성한 파일이 들어있다.
  - fixtures : 테스트에서 사용할 외부 적적 데이터 파일들이 들어가는 위치. 만약 테스트에서 네트워크 응답을 모킹하기 위한 JSON 데이터가 필요하면 이곳에 들어간다.
    - example.json
  - support : Cypress 명령어와 지원 파일이 있다.
    - commands.js
    - e2e.js

```tsx
describe('quote of the day', () => {
  it('display the heading', () => {
    cy.visit('https://icodeit-juntao.github.io/quote-of-the-day/')
    cy.contains('Quote of the day')
  })
})
```

방문하는 웹사이트는 사용자가 페이지를 갱신할 때마다 무작위로 명언을 반환한다.
방문한 후에 cy.contains() 메서드를 통해 오늘의 명언을 포함하는 DOM 요소를 찾아 반환한다.
이 메서드는 텍스트를 포함하는 첫 번째 요소를 반환하며, 찾지 못한다면 테스트는 실패한다.

https://github.com/user-attachments/assets/aa9b7299-fc96-472f-9241-70f3d335c66c

왼쪽 화면에는 테스트 케이스와 진행 상황을 확인할 수 있으며, 마우스를 진행 단계 위에 가져가면 테스트의 각 수행 시점이 스냅샷 화면을 볼 수 있다.

```tsx
it('display a quote', () => {
  cy.visit('https://icodeit-juntao.github.io/quote-of-the-day/')
  cy.get('[data-testid="quote-container"]').should('have.length', 1)
})
```

cy.get() 메서드는 DOM 요소에서 data-testid 속성을 가져오기 위해 사용한다. 이 속성은 보통 테스트에서 자주 변경되는 CSS 선택자나 내용과 관계없이 특정 속성을 쉽게 선택하기 위해 사용한다.

should() 메서드를 호출하여 이 요소의 상태를 검증한다. 여기에서는 요소의 길이, 즉 일치하는 요소의 개수가 1이 맞는지 확인한다. 1이 맞다면 테스트는 성공하고 맞는 요소가 없거나 둘 이상인 경우 실패한다.

### 네트워크 요청 가로채기

몇몇 상황의 경우 UI 동작을 위해 실제 네트워크 요청을 보내고 싶지 않을 때도 있다.
명언이 올바르게 표시되는지 내용을 확인하여 검증하고 싶지만, 명언은 무작위로 생성되므로 네트워크요청을 보내기 전에는 어떤 명언이 표시될지 예측할 수 없습니다. 테스트를 위해서 우리는 네트워크 요청을 보내면서도 응답을 고정시킬 방법이 필요하다. 엔드포인트로 보내는 네트워크 요청을 가로채서 고정된 데이터를 반환하는 방법이 있다.
Cypress에서는 cy.intercept API를 통해 이를 지원한다.

첫 번째로, quote-of-the-day.spec.cy.js에 데이터 배열을 정의한다.

```tsx
const quotes = [
  {
    content:
      'Any fool can write code that a computer can understand. Good programmers write code that humans can understand.',
    author: 'Martin Fowler',
  },
  {
    content: 'Truth can only be found in one place: the code.',
    author: 'Robert C. Martin',
  },
  {
    content:
      'Optimism is an occupational hazard of programming: feedback is the treatment.',
    author: 'Kent Beck',
  },
]

describe('quote of the day', () => {
  it('display the quote content', () => {
    cy.intercept('GET', 'https://api.quotable.io/quotes/random*', {
      statusCode: 200,
      body: quotes,
    })
    cy.visit('https://icodeit-juntao.github.io/quote-of-the-day/')
    cy.contains(
      'Any fool can write code that a computer can understand. Good programmers write code that humans can understand.'
    )
    cy.contains('Martin Fowler')
  })
})
```

https://api.quotable.io/quotes/random으로 시작하는 모든 네트워크 요청을 가로채기 위해 리액트에서 네트워크 요청을 보낼 때마다 Cypress는 요청을 취소하고 quotes 배열을 대신 반환한다.
이 방법으로 테스트를 보다 예측 가능하게 만들며 실제 API 환경의 불안정한 상황으로부터 격리시킬 수 있다.
