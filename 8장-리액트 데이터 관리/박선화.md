Part3 비즈니스 로직과 디자인 패턴 알이보기

# 8장 리액트 데이터 관리

리액트에서 상태 관리는 까다롭습니다. 비즈니스 로직을 코드베이스 내에 어디에 둘지 결정하는 것도 쉽지 않습니다. UI 컴포넌트의 비즈니스 로직이 커지면 재사용성이 떨어집니다. 많은 도메인 객체와 계산 로직들이 의도와 상관없이 UI 컴포넌트에 흩어져 있으면, 로직을 따라가거나 디버깅하기 어렵고 테스트도 쉽지 않습니다. 또한 사용자 경험에 부정적인 영향을 미치는 성능 문제를 야기할 수 있습니다. 또한 Prop Drilling 문제도 있으며, 컴포넌트 간 상태 로직을 공유하는 것도 어렵다.

## 1. 비즈니스 로직 누수 현상

비즈니스 로직은 비즈니스 애플리케이션 운영을 위한 규칙과 계산 로직, 절차 등을 의미합니다. 비즈니스 로직과 관련 없는 컴포넌트나 애플리케이션 영역으로 흘러 들어가는 현상을 비즈니스 로직 누수라 합니다. 비즈니스 로직은 테스트와 유지보수, 재사용을 어렵게 합니다.

프레임워크의 유연성 덕분에 비즈니스 로직을 컴포넌트나 훅 또는 헬퍼 함수에 직접 작성하는 것이 가능하기 때문에, 로직을 당장 필요한 컴포넌트에 끼워 넣다보면 로직의 누수로 이어지게 됩니다.

비즈니스 로직 누수의 가장 흔한 징후는 뷰 또는 UI 컴포넌트 내에서 데이터 변환이 함께 수행되는 것입니다. 데이터 변환은 특정 형식의 데이터를 다른 모듈이나 원격 서비스를 위한 형태로 변환하는 기능을 의미합니다.

## 2. ACL(오류 방지 계층)

소프트웨어 개발에서 ACL은 각각 다른 언어를 사용하는 다른 서브시스템 간의 통역가 또는 중재자 역할을 합니다. 서로 다른 규칙과 구조를 가진 두 시스템을 직접 연결한다면 서로 의도치 않게 영향을 끼칠 수 있고 각각의 고유 도메인 로직을 훼손할 수 있습니다. 특히 복잡한 프런트엔드 애플리케이션 개발에서, ACL은 프런트엔드와 다양한 백엔드 API를 연결해 주는 역할을 합니다.

ACL은 캐시 처리. 오류 변환과 같은 여러 문제를 처리하는 전략 계층으로 활용할 수 있습니다. 이러한 기능들을 한 곳에 집중하면 로직이 여러 프런트엔드 코드베이스에 분산되는 것을 방지하게 되므로 중복 배제 （DRY） 원칙을 준수할 수 있습니다.

### 일반적인 ACL 사용법

외부 데이터 포맷과 무엇을 사용할지를 확인한 후에 변환 함수를 정의하고 공통 위치에 배치한다. 원격 서버에서 수신하는 사용자 데이터 형식에 대해 정의한다.

RemoteUser, User 타입을 정의하여 type 정의 설정을 가지고 transformer.ts 파일에 transformUser 함수를 작성한다.

```tsx
export const transformUser = (remoteUser: RemoteUser): User => { ... }
```

함수를 통해 원격 데이터를 다루고 뷰 레벨의 요구사항에 맞게 가공해 주는 것은 여러 장점이 있습니다.
하지만 백엔드 서비스의 오류로 필요한 데이터를 제공받지 못한다면 복잡도가 높아지게 됩니다. 이러한 상황에 대비하기 위해 대응 로직 또는 기본값을 추가할 필요가 있습니다.

### 예외 상황 대응 또는 기본값

데이터를 변환할 때 자주 보이는 상황 중 하나는 리액트 뷰에 과도하게 방어적인 프로그램을 작성하는 것입니다. 방어적 프로그래밍은 다양한 상황에서 유용하게 사용되는 좋은 방법이지만, 리액트 컴포넌트 안에서 과도하게 널™'' 체크를 하거나 예외 상황에 대한 대응 코드를 작성하는 것은 코드를 복잡하게 하고 이해하기 어렵게 만듭니다.

방어적 프로그래밍은 발생할 수 있는 오류와 실패 또는 예외 상황 등을 자연스럽게 처리하기 위해. 필요한 코드를 작성하는 것을 의미합니다. 애플리케이션이 예상하지 못한 상황에서도 정상으로 복원하기 쉽고 안정적으로 동작하기 위함입니다.

예외 상황의 경우 예를 들어 null 또는 undefined로 값이 오는 경우, 런타임에 예외를 발생시킬 수 있으므로 기본값을 지정하여 원격 데이터가 올바르지 않은 형식으로 전달될 수 있는 상황에 대비해야 합니다. 이러한종류의 로직은 transformUser와 같은 함수로 옮기면 더 효과적으로 테스트할 수 있고 다루기가 더 쉬워집니다.

```tsx
import { RemoteUser, User, UserSubscription } from '../types'

export const transformUser = (remoteUser: RemoteUser): User => {
  return {
    id: remoteUser.user_identification ?? 'N/A',
    name: remoteUser.user_full_name ?? 'Unknown User',
    isPremium: remoteUser.is_premium_user ?? false,
    subscription: (remoteUser.subscription_details?.level ??
      'Basic') as UserSubscription,
    expire: remoteUser.subscription_details?.expiry ?? 'Never',
  }
}
```

이 모든 변환과 예외 처리 로직은 ACL에서 이루어졌습니다. 원격 또는 로컬 데이터 형태가 바뀌면 변경 사항은 이 곳에서 쉽게 적용할 수 있으며. 사용하고 있는 곳의 전체 코드베이스를 모두 살펴볼 필요는 없습니다. 이렇게 ACL 패턴은 효과적으로 비즈니스 로직을 뷰에서 분리할 수 있습니다.

## 3. Prop Drilling 문제 살펴보기

Prop Drilling은 데이터가 필요하지 않은 여러 계층으로 이루어진 컴포넌트들을 통과하여 하위 계층으로 데이터를 전달해야 할 때 발생하는 문제입니다. 이러한 구조는 코드 가독성을 떨어뜨리고 유지보수하기 어렵게 만듭니다.

Context API는 Prop Drilling 문제를 깔끔하게 해결하기에 적합합니다.

## 4. Context API를 통한 Prop Drilling 문제 해결

Context API를 활용하면 더욱 깔끔한 코드 구조를 구현할 수 있습니다. 컴포넌트 계층 구조에 따라 prop을 내려줘야 하는 번거로움 없이 하위 컴포넌트의 구조를 손쉽게 조정할 수 있습니다.
