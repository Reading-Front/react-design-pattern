# 9장 리액트 설계 원칙 적용

설계 원칙은 소프트웨어 개발에서 시간이 지나도 코드베이스의 유지보수성, 확장성, 그리고 가독성을 보장하기 위한 기본 원칙 입니다. 끊임없이 변화하는 기술 환경 속에서도 설계 원칙을 준수한다면 프로젝트의 장기적인 성공을 이끌어낼 수 있으며, 버그가 빈번하게 발생하는 ‘코드 지옥’도 피할수 있습니다. 리액트 개발에 설계 원칙의 적용은 단순한 방법론을 넘어 필수적인 요소입니다. 이는 복잡성에 대응하기 위한 사전적인 조치로, 코드를 읽고 테스트하고 유지보수하기 쉽게 만듭니다.

## 1. 단일책임 원칙 - SRP

단일 책임 원칙의 핵심은 컴포넌트의 주요 역할을 정확히 파악하는 것입니다. 컴포넌트가 수행해야 할 핵심 기능을 분리하면, 부가적인 기능들을 리팩터링하고 추상화하기 쉬워집니다.

단일 책임 원칙은 상위 레벨의 가이드라인으로, 코드 레벨 수준에 직접 적용하기 적합합니다. 이 원칙을 구현하는 방법은 다양하지만, 특히 복잡도가 높아지는 상황에서는 어느 시점에 적용할지 잘 파악해야 합니다.

가장 많이 사용되는 2가지 기술은 render prop과 합성입니다. render prop은 리액트 컴포넌트 간 코드 공유를 위해 함수 prop을 이용하는 기술입니다. render prop으로 구현된 컴포넌트는 자체적으로 렌더링 로직을 구현하는 대신 리액트 요소를 반환하고 이를 호출하는 함수를 사용합니다. 반면에 합성은 작고 재사용 가능한 컴포넌트들을 만들어 이들을 조합해 더 복잡한 UI 요소를 만드는 기술입니다.

### render prop 패턴을 통한 단일 책임 원칙 적용

리액트에서 고차 함수의 이름을 꼭 render로 할 필요는 없습니다. 보다 직관적인 설계를 위해 prop 이름을 children으로 바꾸면, hildren을 일반 함수처럼 호출할수 있습니다.

```tsx
const Title = ({
  title,
  children,
}: {
  title: string
  children: (s: string) => React.ReactNode
}) => <div>{children(title)}</div>

const App = () => {
  return (
    <Title title='This is a title'>
      {(s: string) => {
        const formatted = s.toUpperCase()
        return <h3>{formatted}</h3>
      }}
    </Title>
  )
}
```

Title 컴포넌트는 title prop과 render prop인 child 함수를 전달받습니다. child 함수는 문자 s를 받아 대문자로 바꾸고, h3 태그에 표시합니다. Title 컴포넌트는 전달받은 title prop과 함께 별도 렌더링을 위해 child 함수를 호출합니다.
리액트에서 render prop 패턴은 prop으로 함수를 컴포넌트에 전달합니다. 이 함수는 JSX를 반환하며, 컴포넌트 일부 영역의 렌더링을 담당하게 됩니다. 이 패턴은 부모 컴포넌트가 자식컴포넌트의 렌더링 로직을 제어할 수 있게 하므로 컴포넌트를 더욱 유연하게 하고 재사용할 수 있게 만들어 줍니다. 특히 여러 컴포넌트로 동작을 공유할 때 유용합니다. render prop을 사용하여 새롭게 만든 일반화된 컴포넌트로 재사용 가능한 프레임워크를 만들었습니다. 범용적으로 사용하는 코드를 한 번만 작성했다는 것이 중요합니다.

### 합성을 통한 단일 책임 원칙 적용

[예시] 툴팁이 있는 아바타 컴포넌트

```tsx
const Avatar = ({ name, role, url }: AvatarProps) => {
  if (name) {
    return (
      <Tooltip name={name} role={role}>
        <div className='rounded'>
          <img src={url} alt={`${name}'s profile`} />
        </div>
      </Tooltip>
    )
  }
  return (
    <div className='rounded'>
      <img src={url} alt='' />
    </div>
  )
}
```

사용자가 보다 세부적인 툴팁의 기능을 원한다면, 이렇게 강하게 연결되어 있는 코드를 유지하기 쉽지 않습니다.

```tsx
const Avatar = ({ name = url }: AvatarProps) => (
  <div className='rounded'>
    <img src={url} alt={name} title={name} />
  </div>
)

const MyAvatar = () => (
  <Tooltip name='Juntao Qiu' role='Software Engineer'>
    <Avatar
      name='Juntao Qiu'
      url='https://avatars.githubusercontent.com/u/122324'
    />
  </Tooltip>
)
```

이 접근 방식을 통해 사용자는 Avatar에 영향을 주지 않으면서 Tooltip의 기능을 자유롭게 변경하거나 심지어 다른 툴팁 라이브러리로 교체할 수 있습니다. 결국 분리를 통해 코드의 모듈화가 향상되며, 라이브러리 사용자는 실제로 필요한 기능만 구현하고 그에 따른 복잡도만 관리하면 됩니다.

## 2. 의존관계 역전원칙 - DIP(Dependency Inversion Principle)

의존관계 역전 원칙은 유지보수 가능하며 유연하고 확장 가능한 소프트웨어를 만들기 위해 필요한 SOLID 5가지 원칙 중 하나로, 이 원칙은 구체적인 구현보다는 추상화에 초점을 맞춥니다. 의존관계 역전 원칙은 대규모 시스템을 구축하고 유지 관리할 때 직면하는 문제들을 해결합니다. 그중 하나는 단단하게 결합된 모듈로 인해 발생하는 문제입니다. 상위 레벨의 모듈이 하위 레벨의 모듈에 의존관계를 맺게 되면, 하위 레벨 모듈을 조금만 변경해도 광범위한 영향을 미쳐 시스템 전체의 변경이 필요합니다.

> SOLID의 5가지 원칙은 단일 책임 원칙(single responsibility principle), 개방一폐쇄 원칙(Open-Closed Principle), 리스코프 치환원칙(Uskov Substitution Principle), 인터페이스 분리 원칙(interface segregation principle), 의존관계 역전 원칙(Dependency Inversion Principle)을 의미합니다.

### 버튼 클릭 로그 수집에 의존관계 역전 원칙 적용하기

기존의 버튼을 감싸서, 클릭 핸들러를 가로채는 새로운 컴포넌트를 만듭니다.

의존관계 역전 원칙을 적용하여 기존의 Button 컴포넌트에 변경이 필요하지만, 로그 수집 이벤트를 컴포넌트 안에서 직접 전송하는 대신에 인터페이스를 분리하여 버튼이 인터페이스에 의존하도록 합니다. 이 인터페이스를 준수하는 구현체는 여러 가지가 있습니다.

어떤 구현체는 이벤트를 전송하도록 만들었지만, 로그 수집이 필요 없는 경우에는 빈 구현체를 전달합니다. measure 메서드를 포함한 인터페이스를 가지는 InteractionMeasurement라는 이름의 리액트 컨텍스트를 생성합니다. 이 메서드는 name과 timestamp 매개변수를 선택적으로 받을 수 있습니다. 컨텍스트의 초깃값은 null입니다.

```tsx
export interface InteractionMeasurement {
  measure(name: string | undefined, timestamp?: number): void
}

export default createContext<InteractionMeasurement | null>(null)
```

```tsx
import { ReactNode, SyntheticEvent, useCallback, useContext } from 'react'

import InteractionContext, {
  InteractionMeasurement,
} from './InteractionContext'

interface ButtonType {
  name: string
  onClick: (e: SyntheticEvent<HTMLButtonElement>) => void
  children: ReactNode
}

const Button = ({ name, onClick: providedOnClick, children }: ButtonType) => {
  const interactionContext = useContext<InteractionMeasurement | null>(
    InteractionContext
  )

  const handleClick = useCallback(
    (e: SyntheticEvent<HTMLButtonElement>) => {
      interactionContext && interactionContext.measure(name, e.timeStamp)
      providedOnClick(e)
    },
    [providedOnClick, interactionContext, name]
  )

  return <button onClick={handleClick}>{children}</button>
}

export default Button
```

이 코드는 Interactioncontext를 활용하여 클릭을 추적하는 Button 컴포넌트를 구현합니다. 버튼을 클릭하면 컨텍스트의 measure 메서드를 버튼의 이름과 클릭 이벤트의 타임스탬프를 인자로 전달하여 호출합니다. 이후에 추가로 제공되는 onClick 로직을 실행합니다. 이 방법으로 클릭 추적은 컨텍스트로 추상화하였고, Button 컴포넌트는 재사용성과 유지보수성이 향상되었습니다.
interactioncontext가 null이면, measure 함수는 호출되지 않고 컴포넌트는 prop으로 전달받은 providedOnClick 함수만 실행합니다. 이를 통해 Interactioncontext의 제공 여부에 따라 로그 수집 기능을 선택적으로 적용할 수 있습니다.

```tsx
const FormApp = () => {
  const context = {
    measure: (e: any, t: any) => {
      //send event and timestamp to remote
      console.log(`sending to remote server  ${e}: ${t}`)
    },
  }

  const onClick = () => {
    console.log('submit')
  }

  return (
    <InteractionContext.Provider value={context}>
      <form>
        <Button name='submit-button' onClick={onClick}>
          Submit
        </Button>
      </form>
    </InteractionContext.Provider>
  )
}
```

이 방식은 극도의 동적인 유연함을 제공하여 공통 컴포넌트를 설계할 때 매우 유용합니다. 코드 재사용성과 시스템의 유지보수성을 높여줄 뿐만 아니라 전체 코드 번들 사이즈를 줄일 수 있습니다.
이런 시나리오에서 부가적인 context 객체를 더하는 것이 처음에는 과해 보일 수 있습니다. 하지만 여러 팀과 협업을 수행하는 대규모 코드베이스에서 이러한 방식은 합리적입니다. 예를 들어 상품 팀에서 보고 싶은 통계 분석은 공통 컴포넌트와 원자 컴포넌트를 만드는 것이 목표인 디자인 시스템 팀과는 다를 것입니다. 디자인 시스템 팀은 통계적인 분석에는 관심이 없을 수 있습니다. 이런 환경에서 Button 컴포넌트를 직접 수정하는 것은 실용적이지 않거나 어려울 수 있습니다.

## 3. 명령과조회 책임 분리 원칙 - CQRS

명령과 조회 책임 분리 원칙(Command and Query Responsibility Segregation)은 소프트웨어 설계에서 메서드나 함수는 **시스템의 상태를 수정하는 명령**이거나 **시스템 상태에 대한 정보를 조회하여 반환하는 쿼리** 둘 중에 하나여야 하며, 2가지가 동시에 수행되지 않아야 한다는 원칙입니다.
명령（또는 수정） 메서드는 액션 또는 객체의 상태 변경을 수행하며 값을 반환하지 않습니다. 반면에 조회 메서드는 객체의 상태를 변경 없이 읽습니다. 명령과 조회를 분리하면 컴포넌트 사이에 결합을 분리하여 테스트와 유지보수 및 코드 변경을 쉽게 만듭니다. 또한 동작에 대한 추론이 쉬워져 시스템 전반적인 설계를 개선할 수 있습니다.
이 원칙은 시스템 아키텍처 설계와 같은 대규모 작업에서 널리 사용되지만, 코드 레벨에서도 사용할 수 있습니다.

- [예제] 리액트 Context API와 useReducer 혹을 사용하여 ShoppingApplication 컴포넌트에 명령과 조회 책임 분리 원칙을 적용 - 227p

ShoppingApplication 컴포넌트는 쇼핑 애플리케이션의 메인 인터페이스 역할을 합니다. 리액트의 useContext 혹을 사용하여 장바구니 컨텍스트에 접근하고, 장바구니에 담긴 아이템 목록(items)과 장바구니 담기 함수(additem), 장바구니 제거 함수(removeitem)를 제공합니다. 컴포넌트는 니seTotalPrice 사용자 정의 혹을 통해 장바구니에 담긴 상품의 총 금액을
계산합니다.

```tsx
const ShoppingApplication = () => {
  const context = useContext(ShoppingCartContext)
  const { items, addItem, removeItem } = context
  const totalPrice = useTotalPrice()

  return (
    <div>
      <ProductList addToCart={addItem} />

      <h2>Shopping Cart</h2>
      <ul>
        {items.map((item) => (
          <li key={item.uniqKey}>
            {item.name} - {item.price}
            <button onClick={() => removeItem(item)}>Remove</button>
          </li>
        ))}
      </ul>
      <p>Total Price: {totalPrice}</p>
    </div>
  )
}
```

명령과 조회 책임 분리 원칙은 수정과 조회의 관점에서 시스템을 분리하여 확장성과 유지보수성을 높이고, 전체 구조를 단순하게 만들어주는 디자인 패턴입니다. 아이템 추가 또는 삭제와 같은 장바구니의 상태를 수정하는 명령은 장바구니의 아이템 목록을 가져오고 전체 가격을 계산하는 조회 로직과 분리했습니다. 리액트 Context API와 사용자 정의 훅을 사용하여 깔끔하게 분리할 수 있었고, 각각의 책임을 효과적으로 나눌 수 있었습니다. 이러한 접근 방식은 코드 가독성을 향상시킬 뿐만 아니라 이후에 애플리케이션의 확장과 관리를 용이하게 만듭니다.
